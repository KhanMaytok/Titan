/*!
 * starcitizen-webgl-map v0.9.0 by Lianna Eeftinck
 * Copyright 2015 Lianna Eeftinck
 * https://github.com/Leeft/Star-Citizen-WebGL-Map
 * Licensed under http://opensource.org/licenses/MIT
 */
if (typeof jQuery === "undefined") { throw new Error("starcitizen-webgl-map requires jQuery"); }
if (typeof THREE === "undefined") { throw new Error("starcitizen-webgl-map requires THREE.js"); }
/**
* @author LiannaEeftinck / https://github.com/Leeft
*/

var SCMAP = SCMAP || { REVISION: '3' };

self.console = self.console || {
   info: function () {},
   log: function () {},
   debug: function () {},
   warn: function () {},
   error: function () {}
};

SCMAP.data = {
   factions: [],
   crime_levels: [],
   uee_strategic_values: [],
   goods: [],
   map: {},
   systems: [],
   systemsById: []
};

SCMAP.Symbol = {};
SCMAP.Symbols = {};

SCMAP.Symbol.SIZE = 24;
SCMAP.Symbol.SPACING = 2;

SCMAP.Symbol.getTag = function ( icon ) {
   var $icon = $( '<i title="'+icon.description+'" class="fa fa-fw '+icon.faClass+'"></i>' );
   $icon.css( 'color', icon.color );
   return $icon;
};

SCMAP.Symbols.DANGER = {
   code: "\uf071",
   scale: 0.9,
   faClass: 'fa-warning',
   description: 'Danger, hostile faction',
   color: 'rgba(255,50,50,1.0)'
};
SCMAP.Symbols.WARNING = {
   code: "\uf071",
   scale: 0.9,
   faClass: 'fa-warning',
   description: 'Warning, hostile environment',
   color: 'rgba(255,117,25,1.0)'
};
SCMAP.Symbols.HANGAR = {
   code: "\uf015",
   scale: 1.15,
   faClass: 'fa-home',
   description: 'Hangar location',
   color: 'rgba(255,255,255,1.0)',
   offset: new THREE.Vector2( -0.25, 2 )
};
SCMAP.Symbols.INFO = {
   code: "\uf05a",
   scale: 1.0,
   faClass: 'fa-info-circle',
   description: 'Information available',
   color: 'rgba(255, 162, 255, 1.0)'//,
   //offset: new THREE.Vector2( 0, 2 )
};
SCMAP.Symbols.TRADE = {
   code: "\uf0ec",
   scale: 0.90,
   faClass: 'fa-exchange',
   description: 'Major trade hub',
   color: 'rgba(255,255,0,1.0)',
   offset: new THREE.Vector2( 0, -1 )
};
//SCMAP.Symbols.TRADE = {
//   code: "\uf0d1",
//   scale: 1.0,
//   faClass: 'fa-truck',
//   description: 'Major trade hub',
//   color: 'rgba(255,255,0,1.0)',
//   offset: new THREE.Vector2( -2, -2 )
//};
SCMAP.Symbols.BANNED = {
   code: "\uf05e",
   scale: 1.0,
   faClass: 'fa-ban',
   description: 'System off-limits',
   color: 'rgba(255, 117, 25, 1.0)'
};
SCMAP.Symbols.AVOID = {
   code: "\uf00d",
   scale: 1.2,
   faClass: 'fa-times',
   description: 'Avoid: do not route here',
   color: 'rgba(255,50,50,1.0)'
};
SCMAP.Symbols.COMMENTS = {
   code: "\uf075",
   scale: 1.0,
   faClass: 'fa-comment',
   description: 'Your comments',
   color: 'rgba(106, 187, 207, 1.0)',
   offset: new THREE.Vector2( 0, -3 )
};
SCMAP.Symbols.BOOKMARK = {
   code: "\uf02e",
   scale: 1.05,
   faClass: 'fa-bookmark',
   description: 'Bookmarked',
   color: 'rgba(102, 193, 0, 1.0)',
   offset: new THREE.Vector2( -1, 1 )
};

SCMAP.travelTimeAU = function ( distanceAU ) {
   return( SCMAP.approximateTraveltimePerAU * distanceAU );
};

SCMAP.usersFaction = function ( ) {
   // TODO: allow users to set their faction, if ever needed
   return SCMAP.data.factionsByName.UEE;
};

// constants here

SCMAP.LYtoAU = 63241.077;
SCMAP.approximateTraveltimePerAU = ( ( 8 * 60 ) + 19 ) * 5; // 8:19 at 1c, but autopilot speed is 0.2c

// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.Settings = function () {
   this.storage = null;
   if ( hasLocalStorage() ) {
      this.storage = window.localStorage;
   }

   this.uiWidth = ( this.storage && Number( this.storage['settings.uiWidth'] ) > 0 ) ?
      Number( this.storage['settings.uiWidth'] ) : 320;

   this.labelScale = ( this.storage && Number( this.storage['settings.labelScale'] ) > 0 ) ?
      Number( this.storage['settings.labelScale'] ) : $("#sc-map-configuration").data('defaultLabelScale') || 1.0;
   this.labelScale = Math.max(
      Number( $("#sc-map-configuration").data('minLabelScale') ) || 0.4,
      Math.min( this.labelScale, $("#sc-map-configuration").data('maxLabelScale') || 2.0 )
   );

   this.labelOffset = ( this.storage && Number( this.storage['settings.labelOffset'] ) > 0 ) ?
      Number( this.storage['settings.labelOffset'] ) : $("#sc-map-configuration").data('defaultLabelOffset') || 5.0;
   this.labelOffset = Math.max(
      Number( $("#sc-map-configuration").data('minLabelOffset') ) || -3.5,
      Math.min( this.labelOffset, $("#sc-map-configuration").data('maxLabelOffset') || 7.5 )
   );

   this.systemScale = ( this.storage && Number( this.storage['settings.systemScale'] ) > 0 ) ?
      Number( this.storage['settings.systemScale'] ) : $("#sc-map-configuration").data('defaultSystemScale') || 1.0;
   this.systemScale = Math.max(
      Number( $("#sc-map-configuration").data('minSystemScale') ) || 0.5,
      Math.min( this.systemScale, $("#sc-map-configuration").data('maxSystemScale') || 2.0 )
   );

   this.glow = ( this.storage && this.storage['settings.Glow'] === '0' ) ? false : true;
   this.labels = ( this.storage && this.storage['settings.Labels'] === '0' ) ? false : true;
   this.labelIcons = ( this.storage && this.storage['settings.LabelIcons'] === '0' ) ? false : true;

   this.camera = {
      camera: new THREE.Vector3( 0, 80, 100 ),
      target: new THREE.Vector3( 0, 10, 0 ),
      orientation: {
         theta: 0,
         phi: 0.9616764178488756,
         radius: 122.2
      }
   };

   this.effect = {
      Antialias: true,
      FXAA: false,
      Bloom: false
   };

   this.control = {
      rotationLocked: ( this.storage && this.storage['control.rotationLocked'] === '1' ) ? true : false
   };

   this.renderer = {
      Stats: ( this.storage && this.storage['renderer.Stats'] === '1' ) ? true : false
   };

   this.route = {
      avoidHostile: false,
      avoidOffLimits: false,
      avoidUnknownJumppoints: false
   };

   // Clean up the mess we made

   this.convertAndRemoveOldSettings();

   // Load configs

   this.cameraDefaults = JSON.parse( JSON.stringify( this.camera ) );
   this.cameraDefaults.camera = new THREE.Vector3();
   this.cameraDefaults.camera.copy( this.camera.camera );
   this.cameraDefaults.target = new THREE.Vector3();
   this.cameraDefaults.target.copy( this.camera.target );

   this.load( 'camera' );

   if ( this.storage && 'route' in this.storage ) {
      this.load( 'route' );
   }

   this.load( 'systems' );
   if ( ! this.systems ) { this.systems = {}; }

   this.load( 'effect' );

   this.mode = ( this.storage && (this.storage.mode === '2d') ) ? '2d' : '3d';

   this.mergeAndRemoveOldSettings();
   this.save( 'systems' );
};

SCMAP.Settings.prototype = {

   constructor: SCMAP.Settings,

   load: function save( key ) {
      if ( this.storage && ( key in this.storage ) ) {
         try {
            this[ key ] = JSON.parse( this.storage[ key ] );
         } catch ( e ) {
            console.error( "Error parsing 'localStorage." + key + "'; " + e.name + ": " + e.message );
         }
      }
   },

   save: function save( key ) {
      if ( this.storage && ( key in this ) ) {
         this.storage[ key ] = JSON.stringify( this[ key ] );
      }
   },

   convertAndRemoveOldSettings: function convertAndRemoveOldSettings() {
      if ( ! this.storage ) {
         return;
      }

      if ( 'effect.Bloom' in this.storage ) {
         this.effect.Bloom = ( this.storage['effect.Bloom'] === '1' ) ? true : false;
         delete this.storage['effect.Bloom'];
      }

      if ( 'effect.FXAA' in this.storage ) {
         this.effect.FXAA = ( this.storage['effect.FXAA'] === '1' ) ? true : false;
         delete this.storage['effect.FXAA'];
      }

      delete this.storage['camera.x'];
      delete this.storage['camera.y'];
      delete this.storage['camera.z'];
      delete this.storage['target.x'];
      delete this.storage['target.y'];
      delete this.storage['target.z'];
   },

   mergeAndRemoveOldSettings: function mergeAndRemoveOldSettings() {
      var property, matches, systemId;

      if ( ! this.storage ) {
         return;
      }

      for ( property in this.storage ) {
         if ( ! this.storage.hasOwnProperty( property ) ) {
            continue;
         }

         matches = property.match( /^bookmarks[.](\d+)$/ );
         if ( matches && (this.storage[ property ] === '1') ) {
            systemId = matches[ 1 ];
            if ( this.systems[ systemId ] !== 'object' ) {
               this.systems[ systemId ] = {};
            }
            this.systems[ systemId ].bookmarked = true;
            delete this.storage[ property ];
         }

         matches = property.match( /^hangarLocation[.](\d+)$/ );
         if ( matches && (this.storage[ property ] === '1') ) {
            systemId = matches[ 1 ];
            if ( this.systems[ systemId ] !== 'object' ) {
               this.systems[ systemId ] = {};
            }
            this.systems[ systemId ].hangarLocation = true;
            delete this.storage[ property ];
         }

         matches = property.match( /^comments[.](\d+)$/ );
         if ( matches && (this.storage[ property ] !== '') ) {
            systemId = matches[ 1 ];
            if ( this.systems[ systemId ] !== 'object' ) {
               this.systems[ systemId ] = {};
            }
            this.systems[ systemId ].comments = this.storage[ property ];
            delete this.storage[ property ];
         }
      }
   }

};

SCMAP.settings = new SCMAP.Settings();

function _build_selected_system_object () {
   var object = new THREE.JSONLoader().parse( {
    "metadata" : {
        "formatVersion" : 3.1,
        "sourceFile"    : "selected_system.obj",
        "generatedBy"   : "OBJConverter",
        "vertices"      : 248,
        "faces"         : 248,
        "normals"       : 960,
        "colors"        : 0,
        "uvs"           : 0,
        "materials"     : 1
    },
    "scale" : 1,
    "vertices": [-0.5,0.5,0.5,-0.52,0.2,0.5,-0.52,0.2,0.44,-0.52,0.44,0.44,-0.52,0.5,0.5,-0.5,0.52,0.5,-0.5,0.5,0.52,-0.52,0.44,0.2,-0.52,0.5,0.2,-0.5,0.52,0.2,-0.44,0.52,0.2,-0.44,0.52,0.44,-0.44,0.44,0.52,-0.5,0.2,0.52,-0.44,0.2,0.52,-0.2,0.52,0.44,-0.2,0.52,0.5,-0.2,0.5,0.52,-0.2,0.44,0.52,-0.5,0.44,0.2,-0.5,0.5,0.2,-0.44,0.5,0.2,-0.2,0.44,0.5,-0.2,0.5,0.44,-0.2,0.5,0.5,-0.5,0.44,0.44,-0.44,0.44,0.5,-0.44,0.5,0.44,-0.5,0.2,0.5,-0.5,0.2,0.44,-0.44,0.2,0.5,0.5,0.5,0.5,0.52,0.2,0.5,0.52,0.2,0.44,0.52,0.44,0.44,0.52,0.5,0.5,0.5,0.52,0.5,0.5,0.5,0.52,0.52,0.44,0.2,0.52,0.5,0.2,0.5,0.52,0.2,0.44,0.52,0.2,0.44,0.52,0.44,0.44,0.44,0.52,0.5,0.2,0.52,0.44,0.2,0.52,0.2,0.52,0.44,0.2,0.52,0.5,0.2,0.5,0.52,0.2,0.44,0.52,0.5,0.44,0.2,0.5,0.5,0.2,0.44,0.5,0.2,0.2,0.44,0.5,0.2,0.5,0.44,0.2,0.5,0.5,0.5,0.44,0.44,0.44,0.44,0.5,0.44,0.5,0.44,0.5,0.2,0.5,0.5,0.2,0.44,0.44,0.2,0.5,-0.5,-0.5,0.5,-0.52,-0.2,0.5,-0.52,-0.2,0.44,-0.52,-0.44,0.44,-0.52,-0.5,0.5,-0.5,-0.52,0.5,-0.5,-0.5,0.52,-0.52,-0.44,0.2,-0.52,-0.5,0.2,-0.5,-0.52,0.2,-0.44,-0.52,0.2,-0.44,-0.52,0.44,-0.44,-0.44,0.52,-0.5,-0.2,0.52,-0.44,-0.2,0.52,-0.2,-0.52,0.44,-0.2,-0.52,0.5,-0.2,-0.5,0.52,-0.2,-0.44,0.52,-0.5,-0.44,0.2,-0.5,-0.5,0.2,-0.44,-0.5,0.2,-0.2,-0.44,0.5,-0.2,-0.5,0.44,-0.2,-0.5,0.5,-0.5,-0.44,0.44,-0.44,-0.44,0.5,-0.44,-0.5,0.44,-0.5,-0.2,0.5,-0.5,-0.2,0.44,-0.44,-0.2,0.5,0.5,-0.5,0.5,0.52,-0.2,0.5,0.52,-0.2,0.44,0.52,-0.44,0.44,0.52,-0.5,0.5,0.5,-0.52,0.5,0.5,-0.5,0.52,0.52,-0.44,0.2,0.52,-0.5,0.2,0.5,-0.52,0.2,0.44,-0.52,0.2,0.44,-0.52,0.44,0.44,-0.44,0.52,0.5,-0.2,0.52,0.44,-0.2,0.52,0.2,-0.52,0.44,0.2,-0.52,0.5,0.2,-0.5,0.52,0.2,-0.44,0.52,0.5,-0.44,0.2,0.5,-0.5,0.2,0.44,-0.5,0.2,0.2,-0.44,0.5,0.2,-0.5,0.44,0.2,-0.5,0.5,0.5,-0.44,0.44,0.44,-0.44,0.5,0.44,-0.5,0.44,0.5,-0.2,0.5,0.5,-0.2,0.44,0.44,-0.2,0.5,-0.5,0.5,-0.5,-0.52,0.2,-0.5,-0.52,0.2,-0.44,-0.52,0.44,-0.44,-0.52,0.5,-0.5,-0.5,0.52,-0.5,-0.5,0.5,-0.52,-0.52,0.44,-0.2,-0.52,0.5,-0.2,-0.5,0.52,-0.2,-0.44,0.52,-0.2,-0.44,0.52,-0.44,-0.44,0.44,-0.52,-0.5,0.2,-0.52,-0.44,0.2,-0.52,-0.2,0.52,-0.44,-0.2,0.52,-0.5,-0.2,0.5,-0.52,-0.2,0.44,-0.52,-0.5,0.44,-0.2,-0.5,0.5,-0.2,-0.44,0.5,-0.2,-0.2,0.44,-0.5,-0.2,0.5,-0.44,-0.2,0.5,-0.5,-0.5,0.44,-0.44,-0.44,0.44,-0.5,-0.44,0.5,-0.44,-0.5,0.2,-0.5,-0.5,0.2,-0.44,-0.44,0.2,-0.5,0.5,0.5,-0.5,0.52,0.2,-0.5,0.52,0.2,-0.44,0.52,0.44,-0.44,0.52,0.5,-0.5,0.5,0.52,-0.5,0.5,0.5,-0.52,0.52,0.44,-0.2,0.52,0.5,-0.2,0.5,0.52,-0.2,0.44,0.52,-0.2,0.44,0.52,-0.44,0.44,0.44,-0.52,0.5,0.2,-0.52,0.44,0.2,-0.52,0.2,0.52,-0.44,0.2,0.52,-0.5,0.2,0.5,-0.52,0.2,0.44,-0.52,0.5,0.44,-0.2,0.5,0.5,-0.2,0.44,0.5,-0.2,0.2,0.44,-0.5,0.2,0.5,-0.44,0.2,0.5,-0.5,0.5,0.44,-0.44,0.44,0.44,-0.5,0.44,0.5,-0.44,0.5,0.2,-0.5,0.5,0.2,-0.44,0.44,0.2,-0.5,-0.5,-0.5,-0.5,-0.52,-0.2,-0.5,-0.52,-0.2,-0.44,-0.52,-0.44,-0.44,-0.52,-0.5,-0.5,-0.5,-0.52,-0.5,-0.5,-0.5,-0.52,-0.52,-0.44,-0.2,-0.52,-0.5,-0.2,-0.5,-0.52,-0.2,-0.44,-0.52,-0.2,-0.44,-0.52,-0.44,-0.44,-0.44,-0.52,-0.5,-0.2,-0.52,-0.44,-0.2,-0.52,-0.2,-0.52,-0.44,-0.2,-0.52,-0.5,-0.2,-0.5,-0.52,-0.2,-0.44,-0.52,-0.5,-0.44,-0.2,-0.5,-0.5,-0.2,-0.44,-0.5,-0.2,-0.2,-0.44,-0.5,-0.2,-0.5,-0.44,-0.2,-0.5,-0.5,-0.5,-0.44,-0.44,-0.44,-0.44,-0.5,-0.44,-0.5,-0.44,-0.5,-0.2,-0.5,-0.5,-0.2,-0.44,-0.44,-0.2,-0.5,0.5,-0.5,-0.5,0.52,-0.2,-0.5,0.52,-0.2,-0.44,0.52,-0.44,-0.44,0.52,-0.5,-0.5,0.5,-0.52,-0.5,0.5,-0.5,-0.52,0.52,-0.44,-0.2,0.52,-0.5,-0.2,0.5,-0.52,-0.2,0.44,-0.52,-0.2,0.44,-0.52,-0.44,0.44,-0.44,-0.52,0.5,-0.2,-0.52,0.44,-0.2,-0.52,0.2,-0.52,-0.44,0.2,-0.52,-0.5,0.2,-0.5,-0.52,0.2,-0.44,-0.52,0.5,-0.44,-0.2,0.5,-0.5,-0.2,0.44,-0.5,-0.2,0.2,-0.44,-0.5,0.2,-0.5,-0.44,0.2,-0.5,-0.5,0.5,-0.44,-0.44,0.44,-0.44,-0.5,0.44,-0.5,-0.44,0.5,-0.2,-0.5,0.5,-0.2,-0.44,0.44,-0.2,-0.5],
    "morphTargets": [],
    "morphColors": [],
    "normals": [-0.25969,0.62694,-0.73451,-0.62694,0.25969,-0.73451,-0.91018,0.29289,0.29289,-0.29289,0.91018,0.29289,-0.62694,-0.73451,0.25969,-0.25969,-0.73451,0.62694,-0.29289,0.29289,0.91018,-0.91018,0.29289,0.29289,0.73451,0.25969,0.62694,0.73451,0.62694,0.25969,-0.29289,0.91018,0.29289,-0.29289,0.29289,0.91018,-0.29289,0.29289,0.91018,-0.29289,0.91018,0.29289,-0.91018,0.29289,0.29289,0.57735,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.40825,-0.40825,0.8165,0.40825,-0.40825,-0.8165,0.57735,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.40825,-0.40825,-0.8165,0.40825,-0.40825,0.8165,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.40825,-0.8165,-0.40825,0.40825,0.8165,-0.40825,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.40825,0.8165,-0.40825,0.40825,-0.8165,-0.40825,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.8165,-0.40825,-0.40825,-0.8165,-0.40825,-0.40825,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.8165,-0.40825,-0.40825,0.8165,-0.40825,-0.40825,0.57735,-0.57735,0.57735,0.40825,-0.40825,0.8165,-0.29289,0.29289,0.91018,-0.25969,-0.73451,0.62694,0.40825,-0.40825,0.8165,0.57735,-0.57735,0.57735,0.73451,0.25969,0.62694,-0.29289,0.29289,0.91018,-0.91018,0.29289,0.29289,-0.8165,-0.40825,-0.40825,-0.57735,-0.57735,-0.57735,-0.62694,-0.73451,0.25969,-0.57735,-0.57735,-0.57735,-0.8165,-0.40825,-0.40825,-0.91018,0.29289,0.29289,-0.62694,0.25969,-0.73451,0.40825,0.8165,-0.40825,0.57735,0.57735,-0.57735,-0.25969,0.62694,-0.73451,-0.29289,0.91018,0.29289,0.57735,0.57735,-0.57735,0.40825,0.8165,-0.40825,-0.29289,0.91018,0.29289,0.73451,0.62694,0.25969,0.57735,-0.57735,-0.57735,0.8165,-0.40825,-0.40825,0.57735,-0.57735,-0.57735,0.30151,-0.90453,-0.30151,0.8165,-0.40825,-0.40825,0.57735,-0.57735,-0.57735,0.30151,-0.30151,-0.90453,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.40825,-0.8165,-0.40825,0.57735,-0.57735,-0.57735,0.30151,-0.30151,-0.90453,0.57735,-0.57735,-0.57735,0.40825,-0.8165,-0.40825,0.57735,-0.57735,-0.57735,0.90453,-0.30151,-0.30151,0.40825,-0.40825,-0.8165,0.57735,-0.57735,-0.57735,0.30151,-0.90453,-0.30151,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.40825,-0.40825,-0.8165,0.57735,-0.57735,-0.57735,0.90453,-0.30151,-0.30151,0.57735,-0.57735,-0.57735,0.90453,-0.30151,-0.30151,0.73451,0.25969,0.62694,0.57735,-0.57735,0.57735,0.90453,-0.30151,-0.30151,0.73451,0.62694,0.25969,0.73451,0.25969,0.62694,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.73451,0.62694,0.25969,0.90453,-0.30151,-0.30151,-0.62694,0.25969,-0.73451,-0.25969,0.62694,-0.73451,0.30151,-0.30151,-0.90453,-0.62694,0.25969,-0.73451,0.30151,-0.30151,-0.90453,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.62694,-0.73451,0.25969,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.30151,-0.90453,-0.30151,-0.62694,-0.73451,0.25969,0.30151,-0.90453,-0.30151,-0.25969,-0.73451,0.62694,0.30151,-0.30151,-0.90453,-0.25969,0.62694,-0.73451,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.57735,-0.25969,-0.73451,0.62694,0.30151,-0.90453,-0.30151,0.57735,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.91018,0.29289,0.29289,0.62694,0.25969,-0.73451,0.25969,0.62694,-0.73451,0.29289,0.91018,0.29289,0.29289,0.29289,0.91018,0.25969,-0.73451,0.62694,0.62694,-0.73451,0.25969,0.91018,0.29289,0.29289,0.29289,0.91018,0.29289,-0.73451,0.62694,0.25969,-0.73451,0.25969,0.62694,0.29289,0.29289,0.91018,0.29289,0.91018,0.29289,0.29289,0.29289,0.91018,0.91018,0.29289,0.29289,-0.40825,-0.40825,0.8165,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.40825,-0.40825,-0.8165,-0.40825,-0.40825,-0.8165,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.40825,-0.40825,0.8165,-0.40825,-0.8165,-0.40825,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.40825,0.8165,-0.40825,-0.40825,0.8165,-0.40825,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.40825,-0.8165,-0.40825,-0.8165,-0.40825,-0.40825,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.8165,-0.40825,-0.40825,0.8165,-0.40825,-0.40825,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.8165,-0.40825,-0.40825,0.29289,0.29289,0.91018,-0.40825,-0.40825,0.8165,-0.57735,-0.57735,0.57735,0.25969,-0.73451,0.62694,-0.73451,0.25969,0.62694,-0.57735,-0.57735,0.57735,-0.40825,-0.40825,0.8165,0.29289,0.29289,0.91018,0.57735,-0.57735,-0.57735,0.8165,-0.40825,-0.40825,0.91018,0.29289,0.29289,0.62694,-0.73451,0.25969,0.91018,0.29289,0.29289,0.8165,-0.40825,-0.40825,0.57735,-0.57735,-0.57735,0.62694,0.25969,-0.73451,0.25969,0.62694,-0.73451,-0.57735,0.57735,-0.57735,-0.40825,0.8165,-0.40825,0.29289,0.91018,0.29289,0.29289,0.91018,0.29289,-0.40825,0.8165,-0.40825,-0.57735,0.57735,-0.57735,-0.73451,0.62694,0.25969,-0.57735,-0.57735,-0.57735,-0.8165,-0.40825,-0.40825,-0.57735,-0.57735,-0.57735,-0.30151,-0.90453,-0.30151,-0.30151,-0.30151,-0.90453,-0.57735,-0.57735,-0.57735,-0.8165,-0.40825,-0.40825,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.40825,-0.8165,-0.40825,-0.57735,-0.57735,-0.57735,-0.30151,-0.30151,-0.90453,-0.57735,-0.57735,-0.57735,-0.40825,-0.8165,-0.40825,-0.57735,-0.57735,-0.57735,-0.90453,-0.30151,-0.30151,-0.30151,-0.90453,-0.30151,-0.57735,-0.57735,-0.57735,-0.40825,-0.40825,-0.8165,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.40825,-0.40825,-0.8165,-0.57735,-0.57735,-0.57735,-0.90453,-0.30151,-0.30151,-0.73451,0.25969,0.62694,-0.90453,-0.30151,-0.30151,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.73451,0.62694,0.25969,-0.90453,-0.30151,-0.30151,-0.73451,0.25969,0.62694,-0.73451,0.62694,0.25969,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.90453,-0.30151,-0.30151,0.25969,0.62694,-0.73451,0.62694,0.25969,-0.73451,-0.30151,-0.30151,-0.90453,-0.57735,-0.57735,-0.57735,-0.30151,-0.30151,-0.90453,0.62694,0.25969,-0.73451,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.62694,-0.73451,0.25969,-0.30151,-0.90453,-0.30151,-0.30151,-0.90453,-0.30151,0.62694,-0.73451,0.25969,0.25969,-0.73451,0.62694,-0.57735,0.57735,-0.57735,0.25969,0.62694,-0.73451,-0.30151,-0.30151,-0.90453,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.30151,-0.90453,-0.30151,0.25969,-0.73451,0.62694,-0.57735,-0.57735,0.57735,-0.91018,-0.29289,0.29289,-0.62694,-0.25969,-0.73451,-0.25969,-0.62694,-0.73451,-0.29289,-0.91018,0.29289,-0.29289,-0.29289,0.91018,-0.25969,0.73451,0.62694,-0.62694,0.73451,0.25969,-0.91018,-0.29289,0.29289,-0.29289,-0.91018,0.29289,0.73451,-0.62694,0.25969,0.73451,-0.25969,0.62694,-0.29289,-0.29289,0.91018,-0.29289,-0.91018,0.29289,-0.29289,-0.29289,0.91018,-0.91018,-0.29289,0.29289,0.40825,0.40825,0.8165,0.57735,0.57735,0.57735,0.57735,0.57735,-0.57735,0.40825,0.40825,-0.8165,0.40825,0.40825,-0.8165,0.57735,0.57735,-0.57735,0.57735,0.57735,0.57735,0.40825,0.40825,0.8165,0.40825,0.8165,-0.40825,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.40825,-0.8165,-0.40825,0.40825,-0.8165,-0.40825,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.40825,0.8165,-0.40825,0.8165,0.40825,-0.40825,0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.8165,0.40825,-0.40825,-0.8165,0.40825,-0.40825,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.8165,0.40825,-0.40825,-0.29289,-0.29289,0.91018,0.40825,0.40825,0.8165,0.57735,0.57735,0.57735,-0.25969,0.73451,0.62694,0.73451,-0.25969,0.62694,0.57735,0.57735,0.57735,0.40825,0.40825,0.8165,-0.29289,-0.29289,0.91018,-0.57735,0.57735,-0.57735,-0.8165,0.40825,-0.40825,-0.91018,-0.29289,0.29289,-0.62694,0.73451,0.25969,-0.91018,-0.29289,0.29289,-0.8165,0.40825,-0.40825,-0.57735,0.57735,-0.57735,-0.62694,-0.25969,-0.73451,-0.25969,-0.62694,-0.73451,0.57735,-0.57735,-0.57735,0.40825,-0.8165,-0.40825,-0.29289,-0.91018,0.29289,-0.29289,-0.91018,0.29289,0.40825,-0.8165,-0.40825,0.57735,-0.57735,-0.57735,0.73451,-0.62694,0.25969,0.57735,0.57735,-0.57735,0.8165,0.40825,-0.40825,0.57735,0.57735,-0.57735,0.30151,0.90453,-0.30151,0.30151,0.30151,-0.90453,0.57735,0.57735,-0.57735,0.8165,0.40825,-0.40825,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.40825,0.8165,-0.40825,0.57735,0.57735,-0.57735,0.30151,0.30151,-0.90453,0.57735,0.57735,-0.57735,0.40825,0.8165,-0.40825,0.57735,0.57735,-0.57735,0.90453,0.30151,-0.30151,0.30151,0.90453,-0.30151,0.57735,0.57735,-0.57735,0.40825,0.40825,-0.8165,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.40825,0.40825,-0.8165,0.57735,0.57735,-0.57735,0.90453,0.30151,-0.30151,0.73451,-0.25969,0.62694,0.90453,0.30151,-0.30151,0.57735,0.57735,-0.57735,0.57735,0.57735,0.57735,0.73451,-0.62694,0.25969,0.90453,0.30151,-0.30151,0.73451,-0.25969,0.62694,0.73451,-0.62694,0.25969,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.90453,0.30151,-0.30151,-0.25969,-0.62694,-0.73451,-0.62694,-0.25969,-0.73451,0.30151,0.30151,-0.90453,0.57735,0.57735,-0.57735,0.30151,0.30151,-0.90453,-0.62694,-0.25969,-0.73451,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.62694,0.73451,0.25969,0.30151,0.90453,-0.30151,0.30151,0.90453,-0.30151,-0.62694,0.73451,0.25969,-0.25969,0.73451,0.62694,0.57735,-0.57735,-0.57735,-0.25969,-0.62694,-0.73451,0.30151,0.30151,-0.90453,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.30151,0.90453,-0.30151,-0.25969,0.73451,0.62694,0.57735,0.57735,0.57735,0.25969,-0.62694,-0.73451,0.62694,-0.25969,-0.73451,0.91018,-0.29289,0.29289,0.29289,-0.91018,0.29289,0.62694,0.73451,0.25969,0.25969,0.73451,0.62694,0.29289,-0.29289,0.91018,0.91018,-0.29289,0.29289,-0.73451,-0.25969,0.62694,-0.73451,-0.62694,0.25969,0.29289,-0.91018,0.29289,0.29289,-0.29289,0.91018,0.29289,-0.29289,0.91018,0.29289,-0.91018,0.29289,0.91018,-0.29289,0.29289,-0.57735,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.40825,0.40825,0.8165,-0.40825,0.40825,-0.8165,-0.57735,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.40825,0.40825,-0.8165,-0.40825,0.40825,0.8165,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.40825,0.8165,-0.40825,-0.40825,-0.8165,-0.40825,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.40825,-0.8165,-0.40825,-0.40825,0.8165,-0.40825,0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.8165,0.40825,-0.40825,0.8165,0.40825,-0.40825,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.8165,0.40825,-0.40825,-0.8165,0.40825,-0.40825,-0.57735,0.57735,0.57735,-0.40825,0.40825,0.8165,0.29289,-0.29289,0.91018,0.25969,0.73451,0.62694,-0.40825,0.40825,0.8165,-0.57735,0.57735,0.57735,-0.73451,-0.25969,0.62694,0.29289,-0.29289,0.91018,0.91018,-0.29289,0.29289,0.8165,0.40825,-0.40825,0.57735,0.57735,-0.57735,0.62694,0.73451,0.25969,0.57735,0.57735,-0.57735,0.8165,0.40825,-0.40825,0.91018,-0.29289,0.29289,0.62694,-0.25969,-0.73451,-0.40825,-0.8165,-0.40825,-0.57735,-0.57735,-0.57735,0.25969,-0.62694,-0.73451,0.29289,-0.91018,0.29289,-0.57735,-0.57735,-0.57735,-0.40825,-0.8165,-0.40825,0.29289,-0.91018,0.29289,-0.73451,-0.62694,0.25969,-0.57735,0.57735,-0.57735,-0.8165,0.40825,-0.40825,-0.57735,0.57735,-0.57735,-0.30151,0.90453,-0.30151,-0.8165,0.40825,-0.40825,-0.57735,0.57735,-0.57735,-0.30151,0.30151,-0.90453,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.40825,0.8165,-0.40825,-0.57735,0.57735,-0.57735,-0.30151,0.30151,-0.90453,-0.57735,0.57735,-0.57735,-0.40825,0.8165,-0.40825,-0.57735,0.57735,-0.57735,-0.90453,0.30151,-0.30151,-0.40825,0.40825,-0.8165,-0.57735,0.57735,-0.57735,-0.30151,0.90453,-0.30151,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.40825,0.40825,-0.8165,-0.57735,0.57735,-0.57735,-0.90453,0.30151,-0.30151,-0.57735,0.57735,-0.57735,-0.90453,0.30151,-0.30151,-0.73451,-0.25969,0.62694,-0.57735,0.57735,0.57735,-0.90453,0.30151,-0.30151,-0.73451,-0.62694,0.25969,-0.73451,-0.25969,0.62694,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.57735,-0.73451,-0.62694,0.25969,-0.90453,0.30151,-0.30151,0.62694,-0.25969,-0.73451,0.25969,-0.62694,-0.73451,-0.30151,0.30151,-0.90453,0.62694,-0.25969,-0.73451,-0.30151,0.30151,-0.90453,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.62694,0.73451,0.25969,0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.57735,-0.30151,0.90453,-0.30151,0.62694,0.73451,0.25969,-0.30151,0.90453,-0.30151,0.25969,0.73451,0.62694,-0.30151,0.30151,-0.90453,0.25969,-0.62694,-0.73451,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.57735,0.25969,0.73451,0.62694,-0.30151,0.90453,-0.30151,-0.57735,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.91018,0.29289,-0.29289,-0.62694,0.25969,0.73451,-0.25969,0.62694,0.73451,-0.29289,0.91018,-0.29289,-0.29289,0.29289,-0.91018,-0.25969,-0.73451,-0.62694,-0.62694,-0.73451,-0.25969,-0.91018,0.29289,-0.29289,-0.29289,0.91018,-0.29289,0.73451,0.62694,-0.25969,0.73451,0.25969,-0.62694,-0.29289,0.29289,-0.91018,-0.29289,0.91018,-0.29289,-0.29289,0.29289,-0.91018,-0.91018,0.29289,-0.29289,0.40825,-0.40825,-0.8165,0.57735,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.40825,-0.40825,0.8165,0.40825,-0.40825,0.8165,0.57735,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.40825,-0.40825,-0.8165,0.40825,-0.8165,0.40825,0.57735,-0.57735,0.57735,0.57735,0.57735,0.57735,0.40825,0.8165,0.40825,0.40825,0.8165,0.40825,0.57735,0.57735,0.57735,0.57735,-0.57735,0.57735,0.40825,-0.8165,0.40825,0.8165,-0.40825,0.40825,0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.8165,-0.40825,0.40825,-0.8165,-0.40825,0.40825,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.8165,-0.40825,0.40825,-0.29289,0.29289,-0.91018,0.40825,-0.40825,-0.8165,0.57735,-0.57735,-0.57735,-0.25969,-0.73451,-0.62694,0.73451,0.25969,-0.62694,0.57735,-0.57735,-0.57735,0.40825,-0.40825,-0.8165,-0.29289,0.29289,-0.91018,-0.57735,-0.57735,0.57735,-0.8165,-0.40825,0.40825,-0.91018,0.29289,-0.29289,-0.62694,-0.73451,-0.25969,-0.91018,0.29289,-0.29289,-0.8165,-0.40825,0.40825,-0.57735,-0.57735,0.57735,-0.62694,0.25969,0.73451,-0.25969,0.62694,0.73451,0.57735,0.57735,0.57735,0.40825,0.8165,0.40825,-0.29289,0.91018,-0.29289,-0.29289,0.91018,-0.29289,0.40825,0.8165,0.40825,0.57735,0.57735,0.57735,0.73451,0.62694,-0.25969,0.57735,-0.57735,0.57735,0.8165,-0.40825,0.40825,0.57735,-0.57735,0.57735,0.30151,-0.90453,0.30151,0.30151,-0.30151,0.90453,0.57735,-0.57735,0.57735,0.8165,-0.40825,0.40825,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.40825,-0.8165,0.40825,0.57735,-0.57735,0.57735,0.30151,-0.30151,0.90453,0.57735,-0.57735,0.57735,0.40825,-0.8165,0.40825,0.57735,-0.57735,0.57735,0.90453,-0.30151,0.30151,0.30151,-0.90453,0.30151,0.57735,-0.57735,0.57735,0.40825,-0.40825,0.8165,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.40825,-0.40825,0.8165,0.57735,-0.57735,0.57735,0.90453,-0.30151,0.30151,0.73451,0.25969,-0.62694,0.90453,-0.30151,0.30151,0.57735,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.73451,0.62694,-0.25969,0.90453,-0.30151,0.30151,0.73451,0.25969,-0.62694,0.73451,0.62694,-0.25969,0.57735,0.57735,0.57735,0.57735,-0.57735,0.57735,0.90453,-0.30151,0.30151,-0.25969,0.62694,0.73451,-0.62694,0.25969,0.73451,0.30151,-0.30151,0.90453,0.57735,-0.57735,0.57735,0.30151,-0.30151,0.90453,-0.62694,0.25969,0.73451,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.62694,-0.73451,-0.25969,0.30151,-0.90453,0.30151,0.30151,-0.90453,0.30151,-0.62694,-0.73451,-0.25969,-0.25969,-0.73451,-0.62694,0.57735,0.57735,0.57735,-0.25969,0.62694,0.73451,0.30151,-0.30151,0.90453,0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.30151,-0.90453,0.30151,-0.25969,-0.73451,-0.62694,0.57735,-0.57735,-0.57735,0.25969,0.62694,0.73451,0.62694,0.25969,0.73451,0.91018,0.29289,-0.29289,0.29289,0.91018,-0.29289,0.62694,-0.73451,-0.25969,0.25969,-0.73451,-0.62694,0.29289,0.29289,-0.91018,0.91018,0.29289,-0.29289,-0.73451,0.25969,-0.62694,-0.73451,0.62694,-0.25969,0.29289,0.91018,-0.29289,0.29289,0.29289,-0.91018,0.29289,0.29289,-0.91018,0.29289,0.91018,-0.29289,0.91018,0.29289,-0.29289,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.40825,-0.40825,-0.8165,-0.40825,-0.40825,0.8165,-0.57735,-0.57735,-0.57735,-0.57735,-0.57735,0.57735,-0.40825,-0.40825,0.8165,-0.40825,-0.40825,-0.8165,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.40825,-0.8165,0.40825,-0.40825,0.8165,0.40825,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.40825,0.8165,0.40825,-0.40825,-0.8165,0.40825,0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.8165,-0.40825,0.40825,0.8165,-0.40825,0.40825,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.8165,-0.40825,0.40825,-0.8165,-0.40825,0.40825,-0.57735,-0.57735,-0.57735,-0.40825,-0.40825,-0.8165,0.29289,0.29289,-0.91018,0.25969,-0.73451,-0.62694,-0.40825,-0.40825,-0.8165,-0.57735,-0.57735,-0.57735,-0.73451,0.25969,-0.62694,0.29289,0.29289,-0.91018,0.91018,0.29289,-0.29289,0.8165,-0.40825,0.40825,0.57735,-0.57735,0.57735,0.62694,-0.73451,-0.25969,0.57735,-0.57735,0.57735,0.8165,-0.40825,0.40825,0.91018,0.29289,-0.29289,0.62694,0.25969,0.73451,-0.40825,0.8165,0.40825,-0.57735,0.57735,0.57735,0.25969,0.62694,0.73451,0.29289,0.91018,-0.29289,-0.57735,0.57735,0.57735,-0.40825,0.8165,0.40825,0.29289,0.91018,-0.29289,-0.73451,0.62694,-0.25969,-0.57735,-0.57735,0.57735,-0.8165,-0.40825,0.40825,-0.57735,-0.57735,0.57735,-0.30151,-0.90453,0.30151,-0.8165,-0.40825,0.40825,-0.57735,-0.57735,0.57735,-0.30151,-0.30151,0.90453,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.40825,-0.8165,0.40825,-0.57735,-0.57735,0.57735,-0.30151,-0.30151,0.90453,-0.57735,-0.57735,0.57735,-0.40825,-0.8165,0.40825,-0.57735,-0.57735,0.57735,-0.90453,-0.30151,0.30151,-0.40825,-0.40825,0.8165,-0.57735,-0.57735,0.57735,-0.30151,-0.90453,0.30151,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.40825,-0.40825,0.8165,-0.57735,-0.57735,0.57735,-0.90453,-0.30151,0.30151,-0.57735,-0.57735,0.57735,-0.90453,-0.30151,0.30151,-0.73451,0.25969,-0.62694,-0.57735,-0.57735,-0.57735,-0.90453,-0.30151,0.30151,-0.73451,0.62694,-0.25969,-0.73451,0.25969,-0.62694,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.73451,0.62694,-0.25969,-0.90453,-0.30151,0.30151,0.62694,0.25969,0.73451,0.25969,0.62694,0.73451,-0.30151,-0.30151,0.90453,0.62694,0.25969,0.73451,-0.30151,-0.30151,0.90453,-0.57735,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.62694,-0.73451,-0.25969,0.57735,-0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.30151,-0.90453,0.30151,0.62694,-0.73451,-0.25969,-0.30151,-0.90453,0.30151,0.25969,-0.73451,-0.62694,-0.30151,-0.30151,0.90453,0.25969,0.62694,0.73451,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.57735,0.25969,-0.73451,-0.62694,-0.30151,-0.90453,0.30151,-0.57735,-0.57735,0.57735,-0.57735,-0.57735,-0.57735,-0.25969,-0.62694,0.73451,-0.62694,-0.25969,0.73451,-0.91018,-0.29289,-0.29289,-0.29289,-0.91018,-0.29289,-0.62694,0.73451,-0.25969,-0.25969,0.73451,-0.62694,-0.29289,-0.29289,-0.91018,-0.91018,-0.29289,-0.29289,0.73451,-0.25969,-0.62694,0.73451,-0.62694,-0.25969,-0.29289,-0.91018,-0.29289,-0.29289,-0.29289,-0.91018,-0.29289,-0.29289,-0.91018,-0.29289,-0.91018,-0.29289,-0.91018,-0.29289,-0.29289,0.57735,0.57735,0.57735,0.57735,0.57735,-0.57735,0.40825,0.40825,-0.8165,0.40825,0.40825,0.8165,0.57735,0.57735,-0.57735,0.57735,0.57735,0.57735,0.40825,0.40825,0.8165,0.40825,0.40825,-0.8165,0.57735,-0.57735,0.57735,0.57735,0.57735,0.57735,0.40825,0.8165,0.40825,0.40825,-0.8165,0.40825,0.57735,0.57735,0.57735,0.57735,-0.57735,0.57735,0.40825,-0.8165,0.40825,0.40825,0.8165,0.40825,-0.57735,0.57735,0.57735,0.57735,0.57735,0.57735,0.8165,0.40825,0.40825,-0.8165,0.40825,0.40825,0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.8165,0.40825,0.40825,0.8165,0.40825,0.40825,0.57735,0.57735,-0.57735,0.40825,0.40825,-0.8165,-0.29289,-0.29289,-0.91018,-0.25969,0.73451,-0.62694,0.40825,0.40825,-0.8165,0.57735,0.57735,-0.57735,0.73451,-0.25969,-0.62694,-0.29289,-0.29289,-0.91018,-0.91018,-0.29289,-0.29289,-0.8165,0.40825,0.40825,-0.57735,0.57735,0.57735,-0.62694,0.73451,-0.25969,-0.57735,0.57735,0.57735,-0.8165,0.40825,0.40825,-0.91018,-0.29289,-0.29289,-0.62694,-0.25969,0.73451,0.40825,-0.8165,0.40825,0.57735,-0.57735,0.57735,-0.25969,-0.62694,0.73451,-0.29289,-0.91018,-0.29289,0.57735,-0.57735,0.57735,0.40825,-0.8165,0.40825,-0.29289,-0.91018,-0.29289,0.73451,-0.62694,-0.25969,0.57735,0.57735,0.57735,0.8165,0.40825,0.40825,0.57735,0.57735,0.57735,0.30151,0.90453,0.30151,0.8165,0.40825,0.40825,0.57735,0.57735,0.57735,0.30151,0.30151,0.90453,0.57735,0.57735,0.57735,0.57735,0.57735,0.57735,0.40825,0.8165,0.40825,0.57735,0.57735,0.57735,0.30151,0.30151,0.90453,0.57735,0.57735,0.57735,0.40825,0.8165,0.40825,0.57735,0.57735,0.57735,0.90453,0.30151,0.30151,0.40825,0.40825,0.8165,0.57735,0.57735,0.57735,0.30151,0.90453,0.30151,0.57735,0.57735,0.57735,0.57735,0.57735,0.57735,0.40825,0.40825,0.8165,0.57735,0.57735,0.57735,0.90453,0.30151,0.30151,0.57735,0.57735,0.57735,0.90453,0.30151,0.30151,0.73451,-0.25969,-0.62694,0.57735,0.57735,-0.57735,0.90453,0.30151,0.30151,0.73451,-0.62694,-0.25969,0.73451,-0.25969,-0.62694,0.57735,0.57735,0.57735,0.57735,-0.57735,0.57735,0.73451,-0.62694,-0.25969,0.90453,0.30151,0.30151,-0.62694,-0.25969,0.73451,-0.25969,-0.62694,0.73451,0.30151,0.30151,0.90453,-0.62694,-0.25969,0.73451,0.30151,0.30151,0.90453,0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.62694,0.73451,-0.25969,-0.57735,0.57735,0.57735,0.57735,0.57735,0.57735,0.30151,0.90453,0.30151,-0.62694,0.73451,-0.25969,0.30151,0.90453,0.30151,-0.25969,0.73451,-0.62694,0.30151,0.30151,0.90453,-0.25969,-0.62694,0.73451,0.57735,-0.57735,0.57735,0.57735,0.57735,0.57735,-0.25969,0.73451,-0.62694,0.30151,0.90453,0.30151,0.57735,0.57735,0.57735,0.57735,0.57735,-0.57735,0.91018,-0.29289,-0.29289,0.62694,-0.25969,0.73451,0.25969,-0.62694,0.73451,0.29289,-0.91018,-0.29289,0.29289,-0.29289,-0.91018,0.25969,0.73451,-0.62694,0.62694,0.73451,-0.25969,0.91018,-0.29289,-0.29289,0.29289,-0.91018,-0.29289,-0.73451,-0.62694,-0.25969,-0.73451,-0.25969,-0.62694,0.29289,-0.29289,-0.91018,0.29289,-0.91018,-0.29289,0.29289,-0.29289,-0.91018,0.91018,-0.29289,-0.29289,-0.40825,0.40825,-0.8165,-0.57735,0.57735,-0.57735,-0.57735,0.57735,0.57735,-0.40825,0.40825,0.8165,-0.40825,0.40825,0.8165,-0.57735,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.40825,0.40825,-0.8165,-0.40825,0.8165,0.40825,-0.57735,0.57735,0.57735,-0.57735,-0.57735,0.57735,-0.40825,-0.8165,0.40825,-0.40825,-0.8165,0.40825,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.40825,0.8165,0.40825,-0.8165,0.40825,0.40825,-0.57735,0.57735,0.57735,0.57735,0.57735,0.57735,0.8165,0.40825,0.40825,0.8165,0.40825,0.40825,0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.8165,0.40825,0.40825,0.29289,-0.29289,-0.91018,-0.40825,0.40825,-0.8165,-0.57735,0.57735,-0.57735,0.25969,0.73451,-0.62694,-0.73451,-0.25969,-0.62694,-0.57735,0.57735,-0.57735,-0.40825,0.40825,-0.8165,0.29289,-0.29289,-0.91018,0.57735,0.57735,0.57735,0.8165,0.40825,0.40825,0.91018,-0.29289,-0.29289,0.62694,0.73451,-0.25969,0.91018,-0.29289,-0.29289,0.8165,0.40825,0.40825,0.57735,0.57735,0.57735,0.62694,-0.25969,0.73451,0.25969,-0.62694,0.73451,-0.57735,-0.57735,0.57735,-0.40825,-0.8165,0.40825,0.29289,-0.91018,-0.29289,0.29289,-0.91018,-0.29289,-0.40825,-0.8165,0.40825,-0.57735,-0.57735,0.57735,-0.73451,-0.62694,-0.25969,-0.57735,0.57735,0.57735,-0.8165,0.40825,0.40825,-0.57735,0.57735,0.57735,-0.30151,0.90453,0.30151,-0.30151,0.30151,0.90453,-0.57735,0.57735,0.57735,-0.8165,0.40825,0.40825,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.40825,0.8165,0.40825,-0.57735,0.57735,0.57735,-0.30151,0.30151,0.90453,-0.57735,0.57735,0.57735,-0.40825,0.8165,0.40825,-0.57735,0.57735,0.57735,-0.90453,0.30151,0.30151,-0.30151,0.90453,0.30151,-0.57735,0.57735,0.57735,-0.40825,0.40825,0.8165,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.40825,0.40825,0.8165,-0.57735,0.57735,0.57735,-0.90453,0.30151,0.30151,-0.73451,-0.25969,-0.62694,-0.90453,0.30151,0.30151,-0.57735,0.57735,0.57735,-0.57735,0.57735,-0.57735,-0.73451,-0.62694,-0.25969,-0.90453,0.30151,0.30151,-0.73451,-0.25969,-0.62694,-0.73451,-0.62694,-0.25969,-0.57735,-0.57735,0.57735,-0.57735,0.57735,0.57735,-0.90453,0.30151,0.30151,0.25969,-0.62694,0.73451,0.62694,-0.25969,0.73451,-0.30151,0.30151,0.90453,-0.57735,0.57735,0.57735,-0.30151,0.30151,0.90453,0.62694,-0.25969,0.73451,0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,0.57735,0.57735,0.57735,0.62694,0.73451,-0.25969,-0.30151,0.90453,0.30151,-0.30151,0.90453,0.30151,0.62694,0.73451,-0.25969,0.25969,0.73451,-0.62694,-0.57735,-0.57735,0.57735,0.25969,-0.62694,0.73451,-0.30151,0.30151,0.90453,-0.57735,0.57735,0.57735,-0.57735,0.57735,0.57735,-0.30151,0.90453,0.30151,0.25969,0.73451,-0.62694,-0.57735,0.57735,-0.57735],
    "colors": [],
    "uvs": [[]],
    "faces": [35,9,8,4,5,0,0,1,2,3,35,1,13,6,4,0,4,5,6,7,35,17,16,5,6,0,8,9,10,11,34,6,5,4,0,12,13,14,35,22,18,12,26,0,15,16,17,18,35,14,30,26,12,0,19,20,21,22,35,15,23,27,11,0,23,24,25,26,35,21,10,11,27,0,27,28,29,30,35,7,19,25,3,0,31,32,33,34,35,29,2,3,25,0,35,36,37,38,35,14,12,6,13,0,39,40,41,42,35,12,18,17,6,0,43,44,45,46,35,4,3,2,1,0,47,48,49,50,35,7,3,4,8,0,51,52,53,54,35,11,10,9,5,0,55,56,57,58,35,15,11,5,16,0,59,60,61,62,35,29,25,0,28,0,63,64,65,66,35,25,19,20,0,0,67,68,69,70,35,21,27,0,20,0,71,72,73,74,35,0,27,23,24,0,75,76,77,78,35,26,30,28,0,0,79,80,81,82,35,22,26,0,24,0,83,84,85,86,35,22,24,17,18,0,87,88,89,90,34,24,16,17,0,91,92,93,35,23,15,16,24,0,94,95,96,97,34,8,9,20,0,98,99,100,35,8,20,19,7,0,101,102,103,104,35,1,2,29,28,0,105,106,107,108,34,1,28,13,0,109,110,111,35,20,9,10,21,0,112,113,114,115,35,13,28,30,14,0,116,117,118,119,35,35,39,40,36,0,120,121,122,123,35,37,44,32,35,0,124,125,126,127,35,36,47,48,37,0,128,129,130,131,34,36,37,35,0,132,133,134,35,43,49,53,57,0,135,136,137,138,35,57,61,45,43,0,139,140,141,142,35,58,54,46,42,0,143,144,145,146,35,42,41,52,58,0,147,148,149,150,35,56,50,38,34,0,151,152,153,154,35,34,33,60,56,0,155,156,157,158,35,37,43,45,44,0,159,160,161,162,35,48,49,43,37,0,163,164,165,166,35,33,34,35,32,0,167,168,169,170,35,35,34,38,39,0,171,172,173,174,35,40,41,42,36,0,175,176,177,178,35,36,42,46,47,0,179,180,181,182,35,31,56,60,59,0,183,184,185,186,35,51,50,56,31,0,187,188,189,190,35,31,58,52,51,0,191,192,193,194,35,54,58,31,55,0,195,196,197,198,35,59,61,57,31,0,199,200,201,202,35,31,57,53,55,0,203,204,205,206,35,48,55,53,49,0,207,208,209,210,34,47,55,48,0,211,212,213,35,47,46,54,55,0,214,215,216,217,34,40,39,51,0,218,219,220,35,50,51,39,38,0,221,222,223,224,35,60,33,32,59,0,225,226,227,228,34,59,32,44,0,229,230,231,35,41,40,51,52,0,232,233,234,235,35,61,59,44,45,0,236,237,238,239,35,66,70,71,67,0,240,241,242,243,35,68,75,63,66,0,244,245,246,247,35,67,78,79,68,0,248,249,250,251,34,67,68,66,0,252,253,254,35,74,80,84,88,0,255,256,257,258,35,88,92,76,74,0,259,260,261,262,35,89,85,77,73,0,263,264,265,266,35,73,72,83,89,0,267,268,269,270,35,87,81,69,65,0,271,272,273,274,35,65,64,91,87,0,275,276,277,278,35,68,74,76,75,0,279,280,281,282,35,79,80,74,68,0,283,284,285,286,35,64,65,66,63,0,287,288,289,290,35,66,65,69,70,0,291,292,293,294,35,71,72,73,67,0,295,296,297,298,35,67,73,77,78,0,299,300,301,302,35,62,87,91,90,0,303,304,305,306,35,82,81,87,62,0,307,308,309,310,35,62,89,83,82,0,311,312,313,314,35,85,89,62,86,0,315,316,317,318,35,90,92,88,62,0,319,320,321,322,35,62,88,84,86,0,323,324,325,326,35,79,86,84,80,0,327,328,329,330,34,78,86,79,0,331,332,333,35,78,77,85,86,0,334,335,336,337,34,71,70,82,0,338,339,340,35,81,82,70,69,0,341,342,343,344,35,91,64,63,90,0,345,346,347,348,34,90,63,75,0,349,350,351,35,72,71,82,83,0,352,353,354,355,35,92,90,75,76,0,356,357,358,359,35,102,101,97,98,0,360,361,362,363,35,94,106,99,97,0,364,365,366,367,35,110,109,98,99,0,368,369,370,371,34,99,98,97,0,372,373,374,35,115,111,105,119,0,375,376,377,378,35,107,123,119,105,0,379,380,381,382,35,108,116,120,104,0,383,384,385,386,35,114,103,104,120,0,387,388,389,390,35,100,112,118,96,0,391,392,393,394,35,122,95,96,118,0,395,396,397,398,35,107,105,99,106,0,399,400,401,402,35,105,111,110,99,0,403,404,405,406,35,97,96,95,94,0,407,408,409,410,35,100,96,97,101,0,411,412,413,414,35,104,103,102,98,0,415,416,417,418,35,108,104,98,109,0,419,420,421,422,35,122,118,93,121,0,423,424,425,426,35,118,112,113,93,0,427,428,429,430,35,114,120,93,113,0,431,432,433,434,35,93,120,116,117,0,435,436,437,438,35,119,123,121,93,0,439,440,441,442,35,115,119,93,117,0,443,444,445,446,35,115,117,110,111,0,447,448,449,450,34,117,109,110,0,451,452,453,35,116,108,109,117,0,454,455,456,457,34,101,102,113,0,458,459,460,35,101,113,112,100,0,461,462,463,464,35,94,95,122,121,0,465,466,467,468,34,94,121,106,0,469,470,471,35,113,102,103,114,0,472,473,474,475,35,106,121,123,107,0,476,477,478,479,35,128,132,133,129,0,480,481,482,483,35,130,137,125,128,0,484,485,486,487,35,129,140,141,130,0,488,489,490,491,34,129,130,128,0,492,493,494,35,136,142,146,150,0,495,496,497,498,35,150,154,138,136,0,499,500,501,502,35,151,147,139,135,0,503,504,505,506,35,135,134,145,151,0,507,508,509,510,35,149,143,131,127,0,511,512,513,514,35,127,126,153,149,0,515,516,517,518,35,130,136,138,137,0,519,520,521,522,35,141,142,136,130,0,523,524,525,526,35,126,127,128,125,0,527,528,529,530,35,128,127,131,132,0,531,532,533,534,35,133,134,135,129,0,535,536,537,538,35,129,135,139,140,0,539,540,541,542,35,124,149,153,152,0,543,544,545,546,35,144,143,149,124,0,547,548,549,550,35,124,151,145,144,0,551,552,553,554,35,147,151,124,148,0,555,556,557,558,35,152,154,150,124,0,559,560,561,562,35,124,150,146,148,0,563,564,565,566,35,141,148,146,142,0,567,568,569,570,34,140,148,141,0,571,572,573,35,140,139,147,148,0,574,575,576,577,34,133,132,144,0,578,579,580,35,143,144,132,131,0,581,582,583,584,35,153,126,125,152,0,585,586,587,588,34,152,125,137,0,589,590,591,35,134,133,144,145,0,592,593,594,595,35,154,152,137,138,0,596,597,598,599,35,164,163,159,160,0,600,601,602,603,35,156,168,161,159,0,604,605,606,607,35,172,171,160,161,0,608,609,610,611,34,161,160,159,0,612,613,614,35,177,173,167,181,0,615,616,617,618,35,169,185,181,167,0,619,620,621,622,35,170,178,182,166,0,623,624,625,626,35,176,165,166,182,0,627,628,629,630,35,162,174,180,158,0,631,632,633,634,35,184,157,158,180,0,635,636,637,638,35,169,167,161,168,0,639,640,641,642,35,167,173,172,161,0,643,644,645,646,35,159,158,157,156,0,647,648,649,650,35,162,158,159,163,0,651,652,653,654,35,166,165,164,160,0,655,656,657,658,35,170,166,160,171,0,659,660,661,662,35,184,180,155,183,0,663,664,665,666,35,180,174,175,155,0,667,668,669,670,35,176,182,155,175,0,671,672,673,674,35,155,182,178,179,0,675,676,677,678,35,181,185,183,155,0,679,680,681,682,35,177,181,155,179,0,683,684,685,686,35,177,179,172,173,0,687,688,689,690,34,179,171,172,0,691,692,693,35,178,170,171,179,0,694,695,696,697,34,163,164,175,0,698,699,700,35,163,175,174,162,0,701,702,703,704,35,156,157,184,183,0,705,706,707,708,34,156,183,168,0,709,710,711,35,175,164,165,176,0,712,713,714,715,35,168,183,185,169,0,716,717,718,719,35,195,194,190,191,0,720,721,722,723,35,187,199,192,190,0,724,725,726,727,35,203,202,191,192,0,728,729,730,731,34,192,191,190,0,732,733,734,35,208,204,198,212,0,735,736,737,738,35,200,216,212,198,0,739,740,741,742,35,201,209,213,197,0,743,744,745,746,35,207,196,197,213,0,747,748,749,750,35,193,205,211,189,0,751,752,753,754,35,215,188,189,211,0,755,756,757,758,35,200,198,192,199,0,759,760,761,762,35,198,204,203,192,0,763,764,765,766,35,190,189,188,187,0,767,768,769,770,35,193,189,190,194,0,771,772,773,774,35,197,196,195,191,0,775,776,777,778,35,201,197,191,202,0,779,780,781,782,35,215,211,186,214,0,783,784,785,786,35,211,205,206,186,0,787,788,789,790,35,207,213,186,206,0,791,792,793,794,35,186,213,209,210,0,795,796,797,798,35,212,216,214,186,0,799,800,801,802,35,208,212,186,210,0,803,804,805,806,35,208,210,203,204,0,807,808,809,810,34,210,202,203,0,811,812,813,35,209,201,202,210,0,814,815,816,817,34,194,195,206,0,818,819,820,35,194,206,205,193,0,821,822,823,824,35,187,188,215,214,0,825,826,827,828,34,187,214,199,0,829,830,831,35,206,195,196,207,0,832,833,834,835,35,199,214,216,200,0,836,837,838,839,35,221,225,226,222,0,840,841,842,843,35,223,230,218,221,0,844,845,846,847,35,222,233,234,223,0,848,849,850,851,34,222,223,221,0,852,853,854,35,229,235,239,243,0,855,856,857,858,35,243,247,231,229,0,859,860,861,862,35,244,240,232,228,0,863,864,865,866,35,228,227,238,244,0,867,868,869,870,35,242,236,224,220,0,871,872,873,874,35,220,219,246,242,0,875,876,877,878,35,223,229,231,230,0,879,880,881,882,35,234,235,229,223,0,883,884,885,886,35,219,220,221,218,0,887,888,889,890,35,221,220,224,225,0,891,892,893,894,35,226,227,228,222,0,895,896,897,898,35,222,228,232,233,0,899,900,901,902,35,217,242,246,245,0,903,904,905,906,35,237,236,242,217,0,907,908,909,910,35,217,244,238,237,0,911,912,913,914,35,240,244,217,241,0,915,916,917,918,35,245,247,243,217,0,919,920,921,922,35,217,243,239,241,0,923,924,925,926,35,234,241,239,235,0,927,928,929,930,34,233,241,234,0,931,932,933,35,233,232,240,241,0,934,935,936,937,34,226,225,237,0,938,939,940,35,236,237,225,224,0,941,942,943,944,35,246,219,218,245,0,945,946,947,948,34,245,218,230,0,949,950,951,35,227,226,237,238,0,952,953,954,955,35,247,245,230,231,0,956,957,958,959]
   } );
   return object.geometry;
}
SCMAP.SelectedSystemGeometry = SCMAP.SelectedSystemGeometry || _build_selected_system_object();

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.JumpPoint = function ( data ) {
   this.id = data.jumpPointId;
   this.name = ( typeof data.name === 'string' && data.name.length > 1 ) ? data.name : undefined;
   this.source = ( data.source instanceof SCMAP.System ) ? data.source : undefined;
   this.destination = ( data.destination instanceof SCMAP.System ) ? data.destination : undefined;
   this.drawn = false;
   this.type = ( typeof data.type === 'string' ) ? data.type : 'UNDISC';
   this.entryAU = new THREE.Vector3();
   if ( ( typeof data.entryAU === 'object' ) && Array.isArray( data.entryAU ) ) {
      this.entryAU = this.entryAU.fromArray( data.entryAU );
   }

   if ( !this.isValid() ) {
      console.error( "Invalid route created" );
   } else {
      if ( this.name === undefined || this.name === '' ) {
         this.name = "[" + this.source.name + " to " + this.destination.name + "]";
      }
   }
};

SCMAP.JumpPoint.prototype = {
   constructor: SCMAP.JumpPoint,

   length: function() {
      if ( !this.isValid() ) { return; }
      return this.source.position.distanceTo( this.destination.position );
   },

   jumpTime: function() {
      if ( !this.isValid() ) { return; }
      // TODO FIXME: This is a rough guesstimate on how long it will take
      // to travel a JP, and not based in any facts ... no word from devs
      // on this so far.
      return this.length() * 4; // 2 mins for 30LY, ~Sol to Vega (27LY)
   },

   fuelConsumption: function() {
      if ( !this.isValid() ) { return; }
      // TODO: Devs have stated that JP's don't consume fuel to traverse.
      // If that changes, this needs to be quantified and fixed.
      return 0;
   },

   buildSceneObject: function() {
      var oppositeJumppoint, geometry;

      if ( this.drawn ) {
         return;
      }

      // Check if the opposite jumppoint has already been drawn
      oppositeJumppoint = this.getOppositeJumppoint();
      if ( oppositeJumppoint instanceof SCMAP.JumpPoint && oppositeJumppoint.drawn ) {
         return;
      }

      geometry = new THREE.Geometry();
      geometry.colors.push( this.source.faction.lineColor );
      geometry.vertices.push( this.source.sceneObject.position );
      geometry.colors.push( this.destination.faction.lineColor );
      geometry.vertices.push( this.destination.sceneObject.position );

      // Set both the jumppoints as drawn
      this.setDrawn();
      if ( oppositeJumppoint instanceof SCMAP.JumpPoint ) {
         oppositeJumppoint.setDrawn();
      }

      // This is apparently needed for dashed lines
      geometry.computeLineDistances();
      return new THREE.Line( geometry, this.getMaterial(), THREE.LinePieces );
   },

   getOppositeJumppoint: function() {
      for ( var i = 0; i < this.destination.jumpPoints.length; i++ ) {
         var jumppoint = this.destination.jumpPoints[i];
         if ( jumppoint.destination == this.source ) {
            return jumppoint;
         }
      }
   },

   getMaterial: function() {
      if ( this.type in SCMAP.JumpPoint.Material ) {
         return SCMAP.JumpPoint.Material[ this.type ];
      } else {
         return SCMAP.JumpPoint.Material.DEFAULT;
      }
   },

   isValid: function() {
      return( this.source instanceof SCMAP.System &&
         this.destination instanceof SCMAP.System &&
         this.source !== this.destination );
   },

   isUnconfirmed: function() {
      return ( ( this.type === 'UNCONF' ) || ( this.type === 'UNDISC' ) );
   },

   setDrawn: function() {
      this.drawn = true;
   }
};

SCMAP.JumpPoint.Material = {
   NORMAL: new THREE.LineBasicMaterial({
      color: 0xFFFFFF,
      linewidth: 2,
      vertexColors: true
   }),
   UNDISC: new THREE.LineDashedMaterial({
      color: 0xFFFFFF,
      dashSize: 0.75,
      gapSize: 0.75,
      linewidth: 2,
      vertexColors: true
   }),
   UNCONF: new THREE.LineDashedMaterial({
      color: 0xFFFFFF,
      dashSize: 2,
      gapSize: 2,
      linewidth: 2,
      vertexColors: true
   })
};
SCMAP.JumpPoint.Material.DEFAULT = SCMAP.JumpPoint.Material.UNCONF;

// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.Faction = function ( data ) {

   this.id = undefined;
   this.name = 'Unclaimed';
   this.isRealFaction = false;
   this.color = new THREE.Color( 0xFFFFFF );
   this.planeColor = new THREE.Color( 0xFF0000 );
   this.lineColor = new THREE.Color( 0xFFFF00 );
   this.parentFaction = null;

   this.setValues( data );

   // Internals
   this._claimed = {
      systems: {}
   };
   this._darkMaterial = undefined;

};

SCMAP.Faction.prototype = {
   constructor: SCMAP.Faction,

   claim: function ( system ) {
      if ( ! system instanceof SCMAP.System ) {
         new Error( "A faction can only claim ownership over a system" );
         return;
      }
      this._claimed.systems[ system.uuid ] = true;
      return this;
   },

   claimed: function ( system ) {
      if ( ! system instanceof SCMAP.System ) {
         new Error( "A faction can only test ownership over a system" );
         return;
      }
      return this._claimed.systems[ system.uuid ];
   },

   material: function ( ) {
      if ( typeof this._darkMaterial === 'undefined' ) {
         this._darkMaterial = new THREE.MeshBasicMaterial({
            color: this.planeColor, vertexColors: true });
      }
      return this._darkMaterial;
   },

   isHostileTo: function ( comparedTo ) {
      if ( !( comparedTo instanceof SCMAP.Faction ) ) {
         throw "Can only compare to other factions";
      }
      // TODO: more data in database, more logic here
      // rather than lots of hardcoding
      if ( comparedTo.name === 'Vanduul' ) {
         return ( this.name !== 'Vanduul' );
      } else {
         return ( this.name === 'Vanduul' );
      }
   },

   getValue: function ( key ) {
      if ( key === undefined ) {
         return;
      }
      var value = this[ key ];
      return value;
   },

   setValues: function ( values ) {
      if ( values === undefined ) {
         return;
      }

      for ( var key in values ) {

         var newValue = values[ key ];
         if ( newValue === undefined ) {
            console.log( 'SCMAP.Faction: "' + key + '" parameter is undefined for "'+this.name+'"' );
            continue;
         }

         if ( key in this )
         {
            var currentValue = this[ key ];
            if ( currentValue instanceof THREE.Color ) {

               if ( newValue instanceof THREE.Color ) {
                  this[ key ] = newValue;
               } else {
                  newValue = newValue.replace( '0x', '#' );
                  this[ key ] = new THREE.Color( newValue );
               }
               if ( key === 'color' ) {
                  this.planeColor = this[ key ].clone().offsetHSL( 0, 0.5, 0 ).multiplyScalar( 0.20 );
                  this.lineColor = this[ key ].clone().offsetHSL( 0, 0.05, -0.05 );
               }

            } else {
               this[ key ] = newValue;
            }
         }

      }
   }
};

SCMAP.Faction.preprocessFactions = function ( data ) {
   var factionId, faction;

   SCMAP.data.factionsByName = {};

   for ( factionId in data ) {

      if ( data.hasOwnProperty( factionId ) ) {

         faction = data[ factionId ];

         if ( !( faction instanceof SCMAP.Faction ) ) {

            faction = new SCMAP.Faction({
               id: factionId,
               name: faction.name,
               color: faction.color,
               isRealFaction: faction.isRealFaction,
               parentFaction: null
            });

         }

         SCMAP.data.factions[ factionId ]          = faction;
         SCMAP.data.factionsByName[ faction.id ]   = faction;
         SCMAP.data.factionsByName[ faction.name ] = faction;

      }
   }
};

SCMAP.Faction.getById = function ( id ) {
   var faction = SCMAP.data.factions[ id ];
   if ( ! ( faction instanceof SCMAP.Faction ) ) {
      faction = SCMAP.data.factionsByName.Unclaimed;
   }
   return faction;
};

SCMAP.Faction.getByName = function ( name ) {
   var faction = SCMAP.data.factionsByName[ name ];
   if ( ! ( faction instanceof SCMAP.Faction ) ) {
      faction = SCMAP.data.factionsByName.Unclaimed;
   }
   return faction;
};

// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.Goods = function ( data ) {

   this.id = undefined;
   this.name = 'Unknown';
   this.blackMarket = false;

   this.setValues( data );

   // Internals
   this._trade = {
      importing: [],
      exporting: [],
      blackMarket: []
   };

};

SCMAP.Goods.prototype = {
   constructor: SCMAP.Goods,

   getValue: function ( key ) {
      if ( key === undefined ) {
         return;
      }
      var value = this[ key ];
      return value;
   },

   setValues: function ( values ) {
      if ( values === undefined ) {
         return;
      }

      for ( var key in values ) {

         var newValue = values[ key ];
         if ( newValue === undefined ) {
            console.log( 'SCMAP.Goods: "' + key + '" parameter is undefined for "'+this.name+'"' );
            continue;
         }

         if ( key in this )
         {
            var currentValue = this[ key ];
            this[ key ] = newValue;
         }

      }
   }
};

SCMAP.Goods.preprocessGoods = function ( data ) {
   var goodsId, goods;

   SCMAP.data.goodsByName = {};

   for ( goodsId in SCMAP.data.goods ) {

      if ( SCMAP.data.goods.hasOwnProperty( goodsId ) ) {

         goods = SCMAP.data.goods[ goodsId ];
         if ( goods instanceof SCMAP.Goods ) {
            SCMAP.data.goodsByName[ goods.name ] = goods;
            continue;
         }

         goods = new SCMAP.Goods({
            id: goodsId,
            name: goods.name,
            blackMarket: goods.blackMarket
         });

         SCMAP.data.goods[ goodsId ] = goods;
         SCMAP.data.goodsByName[ goods.name ] = goods;
      }
   }
};

SCMAP.Goods.getById = function ( id ) {
   return SCMAP.data.goods[ id ];
};
SCMAP.Goods.getByName = function ( name ) {
   return SCMAP.data.goodsByName[ name ];
};

// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.System = function ( data ) {
   // Defaults, to be filled in from the config
   this.id = undefined;
   this.uuid = undefined;
   this.name = THREE.Math.generateUUID();
   this.nickname = '';
   this.position = new THREE.Vector3();
   this.faction = new SCMAP.Faction();
   this.size = 'medium';
   this.jumpPoints = [];
   this.poi = [];
   this.color = new THREE.Color( 0xFFFFFF );
   this.planets = 0;
   this.planetaryRotation = [];
   this.import = [];
   this.export = [];
   this.status = 'unknown';
   this.crimeStatus = '';
   this.blackMarket = [];
   this.ueeStrategicValue = undefined;
   this.info = [];
   this.scale = 1.0;
   this.binary = false;
   this.isOffLimits = false;
   this.hasWarning = false;
   this.isMajorTradeHub = false;

   this.setValues( data );

   // Generated, internal
   this._routeObjects = [];
   this._drawnText = '';
   this._drawnSymbols = '';
};

SCMAP.System.prototype = {
   constructor: SCMAP.System,

   buildSceneObject: function buildSceneObject() {
      var interactable, interactableSize, starLOD, star, glow;

      // Grouping all our system related objects in here
      var sceneObject = new THREE.Object3D();

      // To make systems easier to click, we add an invisible sprite to them
      // (probably also easier for the raycaster) and use that as the object
      // to interact with
      interactable = new THREE.Sprite( SCMAP.System.INTERACTABLE_DEBUG_MATERIAL );
      interactableSize = Math.min( 5.75, Math.max( 5.5, 6 * this.scale ) );
      interactable.scale.set( interactableSize, interactableSize, interactableSize );
      sceneObject.userData.interactable = interactable;
      sceneObject.add( interactable );

      var scale = this.scale * SCMAP.settings.systemScale;

      // LOD for the stars to make them properly rounded when viewed up close
      // yet low on geometry at a distance
      starLOD = new THREE.LOD();
      for ( i = 0; i < SCMAP.System.STAR_LOD_MESHES.length; i++ ) {
         star = new THREE.Mesh( SCMAP.System.STAR_LOD_MESHES[ i ][ 0 ], this.starMaterial() );
         star.scale.set( this.scale, this.scale, this.scale );
         star.updateMatrix();
         star.matrixAutoUpdate = false;
         starLOD.addLevel( star, SCMAP.System.STAR_LOD_MESHES[ i ][ 1 ] );
      }
      starLOD.scale.set( SCMAP.settings.systemScale, SCMAP.settings.systemScale, SCMAP.settings.systemScale );
      starLOD.updateMatrix();
      starLOD.matrixAutoUpdate = false;
      starLOD.userData.scale = SCMAP.settings.systemScale;
      starLOD.userData.isSystem = true;
      sceneObject.userData.starLOD = starLOD;
      sceneObject.add( starLOD );

      // Glow sprite for the star
      glow = new THREE.Sprite( this.glowMaterial() );
      glow.scale.set( SCMAP.System.GLOW_SCALE * scale, SCMAP.System.GLOW_SCALE * scale, 1.0 );
      glow.position.set( 0, 0, -0.2 );
      glow.userData.isGlow = true;
      glow.userData.scale = this.scale;
      glow.sortParticles = true;
      glow.visible = SCMAP.settings.glow;
      sceneObject.userData.glowSprite = glow;
      sceneObject.add( glow );

      this.systemLabel = this.systemLabel( SCMAP.settings.labelIcons );
      if ( this.systemLabel && this.systemLabel.sceneObject ) {
         this.systemLabel.sceneObject.userData.isLabel = true;
         this.systemLabel.sceneObject.visible = SCMAP.settings.labels;
         sceneObject.add( this.systemLabel.sceneObject );
      }

      sceneObject.position.copy( this.position );
      if ( storage && storage.mode === '2d' ) {
         sceneObject.position.setY( sceneObject.position.y * 0.005 );
      }

      sceneObject.userData.system = this;
      sceneObject.userData.scaleY = this.scaleY;
      return sceneObject;
   },

   updateSceneObject: function updateSceneObject( scene ) {
      for ( var i = 0; i < this.sceneObject.children.length; i++ ) {
         var object = this.sceneObject.children[i];
         if ( object.userData.isLabel ) {
            if ( this.systemLabel instanceof SCMAP.SystemLabel ) {
               this.systemLabel.update( SCMAP.settings.labelIcons );
            }
            object.visible = SCMAP.settings.labels;
         } else if ( object.userData.isGlow ) {
            object.visible = SCMAP.settings.glow;
         }
      }
   },

   setLabelScale: function setLabelScale( vector ) {
      for ( var i = 0; i < this.sceneObject.children.length; i++ ) {
         if ( this.sceneObject.children[i].userData.isLabel ) {
            this.sceneObject.children[i].scale.copy( vector );
         }
      }
   },

   starMaterial: function starMaterial() {
      return SCMAP.System.STAR_MATERIAL;
   },

   //glowShaderMaterial: function glowShaderMaterial( color ) {
   //   var material = SCMAP.System.GLOW_SHADER_MATERIAL.clone();
   //   material.uniforms.glowColor.value = color;
   //   return material;
   //},

   glowMaterial: function glowMaterial() {
      var color = this.color;
      if ( color.equals( SCMAP.Color.BLACK ) ) {
         color.copy( SCMAP.Color.UNSET );
      }
      return new THREE.SpriteMaterial({
         map: SCMAP.System.GLOW_MAP,
         blending: THREE.AdditiveBlending,
         useScreenCoordinates: false,
         color: color
      });
   },

   systemLabel: function systemLabel( drawSymbols ) {
      var texture, material, label, node, uvExtremes;

      if ( ! SCMAP.UI.fontAwesomeIsReady ) {
         drawSymbols = false;
      }

      label = new SCMAP.SystemLabel( this );
      node = window.renderer.textureManager.allocateTextureNode( label.width(), label.height() );
      if ( ! node ) {
         return null;
      }

      label.node = node;
      label.drawText();
      if ( drawSymbols ) {
         label.drawSymbols();
      }

      node.setUV();

      label.sceneObject = new THREE.Sprite( new THREE.SpriteMaterial({ map: node.texture }) );

      label.sceneObject.addEventListener( 'removed', function() {
         // Removes the label on disposal as it's a recursive structure
         label.sceneObject.userData.systemLabel = null;
      });
      label.sceneObject.userData.systemLabel = label;

      label.positionSprite( window.renderer.cameraRotationMatrix() );
      label.scaleSprite();

      return label;
   },

   createInfoLink: function createInfoLink( noSymbols, noTarget ) {
      var $line = $( '<a></a>' );

      if ( typeof this.faction !== 'undefined' && typeof this.faction !== 'undefined' ) {
         $line.css( 'color', this.faction.color.getStyle() );
      }

      $line.addClass('system-link');
      $line.attr( 'data-goto', 'system' );
      $line.attr( 'data-system', this.id );
      $line.attr( 'href', '#system='+encodeURIComponent( this.name ) );
      $line.attr( 'title', 'Show information on '+this.name );
      if ( noTarget ) {
         $line.text( this.name );
      } else {
         $line.html( '<i class="fa fa-crosshairs"></i>&nbsp;' + this.name );
      }

      if ( !noSymbols )
      {
         var symbols = this.getSymbols();
         if ( symbols.length )
         {
            var $span = $('<span class="icons"></span>');
            for ( var i = 0; i < symbols.length; i++ ) {
               $span.append( SCMAP.Symbol.getTag( symbols[i] ) );
            }
            $line.append( $span );
         }
      }

      return $line;
   },

   symbolsToKey: function symbolsToKey( symbols ) {
      var list = [];
      for ( var i = 0; i < symbols.length; i++ ) {
         list.push( symbols[i].code );
      }
      return list.join( ';' );
   },

   getIcons: function getIcons() {
      return this.getSymbols();
   },

   getSymbols: function getSymbols() {
      var mySymbols = [];
      if ( false && this.name === 'Sol' ) {
         mySymbols.push( SCMAP.Symbols.DANGER );
         mySymbols.push( SCMAP.Symbols.WARNING );
         mySymbols.push( SCMAP.Symbols.INFO );
         mySymbols.push( SCMAP.Symbols.TRADE );
         mySymbols.push( SCMAP.Symbols.BANNED );
         mySymbols.push( SCMAP.Symbols.HANGAR );
         mySymbols.push( SCMAP.Symbols.BOOKMARK );
         mySymbols.push( SCMAP.Symbols.AVOID );
         mySymbols.push( SCMAP.Symbols.COMMENTS );
         return mySymbols;
      }
      if ( this.faction.isHostileTo( SCMAP.usersFaction() ) ) { mySymbols.push( SCMAP.Symbols.DANGER ); }
      if ( this.hasWarning ) { mySymbols.push( SCMAP.Symbols.WARNING ); }
      if ( this.info.length ) { mySymbols.push( SCMAP.Symbols.INFO ); }
      if ( this.isMajorTradeHub ) { mySymbols.push( SCMAP.Symbols.TRADE ); }
      if ( this.isOffLimits ) { mySymbols.push( SCMAP.Symbols.BANNED ); }
      if ( this.hasHangar() ) { mySymbols.push( SCMAP.Symbols.HANGAR ); }
      if ( this.isBookmarked() ) { mySymbols.push( SCMAP.Symbols.BOOKMARK ); }
      if ( this.isToBeAvoided() ) { mySymbols.push( SCMAP.Symbols.AVOID ); }
      if ( this.hasComments() ) { mySymbols.push( SCMAP.Symbols.COMMENTS ); }
      return mySymbols;
   },

   displayInfo: function displayInfo( doNotSwitch ) {
      var me = this;
      var previous = null;
      var next = null;
      var currentStep = window.map.route().indexOfCurrentRoute( this );

      if ( typeof currentStep === 'number' )
      {
         var currentRoute = window.map.route().currentRoute();

         if ( currentStep > 0 ) {
            previous = currentRoute[ currentStep - 1 ].system;
            if ( ( currentStep > 1 ) && ( previous === currentRoute[ currentStep ].system ) ) {
               previous = currentRoute[ currentStep - 2 ].system;
            }
            previous = previous;
         }

         if ( currentStep < ( currentRoute.length - 1 ) ) {
            next = currentRoute[ currentStep + 1 ].system;
            if ( ( currentStep < ( currentRoute.length - 2 ) ) && ( next === currentRoute[ currentStep ].system ) ) {
               next = currentRoute[ currentStep + 2 ].system;
            }
         }
      }

      var $element = $( SCMAP.UI.Tab('system').id )
         .empty()
         .append( SCMAP.UI.Templates.systemInfo({
            previous: previous,
            system: me,
            next: next
         }));

      // Set user's notes and bookmarks
      $element.find('.user-system-ishangar').prop( 'checked', this.hasHangar() ).attr( 'data-system', this.id );
      $element.find('.user-system-bookmarked').prop( 'checked', this.isBookmarked() ).attr( 'data-system', this.id );
      $element.find('.user-system-avoid').prop( 'checked', this.isToBeAvoided() ).attr( 'data-system', this.id );

      if ( this.hasComments() ) {
         $element.find('.user-system-comments').empty().val( this.getComments() );
         $element.find('.user-system-comments-md').html( $( markdown.toHTML( this.getComments() ) ) );
      } else {
         $element.find('.user-system-comments').empty().val('');
         $element.find('.user-system-comments-md').empty();
      }

      if ( !doNotSwitch ) {
         ui.toTab( 'system' );
         ui.updateHeight();
      }
   },

   // 2d/3d tween callback
   scaleY: function scaleY( object, scalar ) {
      var wantedY = object.userData.system.position.y * ( scalar / 100 );
      object.userData.system.sceneObject.translateY( wantedY - object.userData.system.sceneObject.position.y );
      object.userData.system.routeNeedsUpdate();
      return this;
   },

   moveTo: function moveTo( vector ) {
      this.system.sceneObject.position.copy( vector );
      this.system.routeNeedsUpdate();
      return this;
   },

   translateVector: function translateVector( vector ) {
      this.system.sceneObject.add( vector );
      this.system.routeNeedsUpdate();
      return this;
   },

   routeNeedsUpdate: function routeNeedsUpdate() {
      for ( var j = 0; j < this._routeObjects.length; j++ ) {
         this._routeObjects[j].geometry.verticesNeedUpdate = true;
      }
      return this;
   },

   // Returns the jumppoint leading to the given destination
   jumpPointTo: function jumpPointTo( destination ) {
      for ( var i = 0; i < this.jumpPoints.length; i++ ) {
         if ( this.jumpPoints[i].destination === destination ) {
            return this.jumpPoints[i];
         }
      }
   },

   isBookmarked: function isBookmarked( ) {
      return this.storedSettings().bookmarked === true;
   },

   isUnknown: function isUnknown( ) {
      return ( this.status === 'unknown' ) ? true : false;
   },

   setBookmarkedState: function setBookmarkedState( state ) {
      this.storedSettings().bookmarked = ( state ) ? true : false;
      this.saveSettings();
      return this;
   },

   hasHangar: function hasHangar( ) {
      return this.storedSettings().hangarLocation === true;
   },

   setHangarState: function setHangarState( state ) {
      this.storedSettings().hangarLocation = ( state ) ? true : false;
      this.saveSettings();
      return this;
   },

   isToBeAvoided: function isToBeAvoided( ) {
      return this.storedSettings().avoid === true;
   },

   setToBeAvoidedState: function setToBeAvoidedState( state ) {
      this.storedSettings().avoid = ( state ) ? true : false;
      this.saveSettings();
      return this;
   },

   hasComments: function hasComments( ) {
      return( ( typeof this.storedSettings().comments === 'string' ) && ( this.storedSettings().comments.length > 0 ) );
   },

   getComments: function getComments( ) {
      return this.storedSettings().comments;
   },

   setComments: function setComments( comments ) {
      if ( (typeof comments === 'string') && (comments.length > 1) ) {
         this.storedSettings().comments = comments;
      } else {
         delete this.storedSettings().comments;
      }
      this.saveSettings();
      return this;
   },

   storedSettings: function storedSettings() {
      if ( !( this.id in SCMAP.settings.systems ) ) {
         SCMAP.settings.systems[ this.id ] = {};
      }
      return SCMAP.settings.systems[ this.id ];
   },

   saveSettings: function saveSettings() {
      SCMAP.settings.save('systems');
      return this;
   },

   toString: function toString() {
      return this.name;
   },

   getValue: function getValue( key ) {
      if ( key === undefined ) {
         return;
      }
      var value = this[ key ];
      return value;
   },

   factionStyle: function factionStyle() {
      return this.faction.color.getStyle();
   },

   _fixJumpPoints: function _fixJumpPoints( cleanup ) {
      var i, jumpPoint, destination, jumpPoints = [];

      for ( i = 0; i < this.jumpPoints.length; i++ )
      {
         jumpPoint = this.jumpPoints[ i ];

         if ( jumpPoint instanceof SCMAP.JumpPoint ) {
            continue;
         }

         destination = SCMAP.System.getById( jumpPoint.destinationSystemId );

         if ( destination instanceof SCMAP.System ) {
            jumpPoint = new SCMAP.JumpPoint({
               source: this,
               destination: destination,
               name: jumpPoint.name,
               type: jumpPoint.type,
               entryAU: jumpPoint.coordsAu
            });
            if ( cleanup ) {
               jumpPoints.push( jumpPoint );
            } else {
               system.jumpPoints[ i ] = jumpPoint;
            }
         }
      }

      if ( cleanup ) {
         this.jumpPoints = jumpPoints;
      }

      return this;
   },

   setValues: function setValues( values ) {
      var key, currentValue, newValue, jumpPoint;

      if ( values === undefined ) {
         return;
      }

      for ( key in values ) {
         newValue = values[ key ];
         if ( newValue === undefined ) {
            console.log( 'SCMAP.System: "' + key + '" parameter is undefined for "'+this.name+'"' );
            continue;
         }

         if ( key in this )
         {
            currentValue = this[ key ];

            if ( key == 'size' ) {
               switch ( newValue ) {
                  case 'dwarf': this.scale = 0.90; break;
                  case 'medium': this.scale = 1.0; break;
                  case 'large': this.scale = 1.15; break;
                  case 'giant': this.scale = 1.27; break;
                  case 'binary': this.scale = 1.4; this.binary = true; break;
               }
               this[ key ] = newValue;
            }

            if ( currentValue instanceof THREE.Color ) {

               if ( newValue instanceof THREE.Color ) {
                  this[ key ] = newValue;
               } else {
                  newValue = newValue.replace( '0x', '#' );
                  this[ '_'+key ] = newValue;
                  this[ key ] = new THREE.Color( newValue );
               }

            } else if ( currentValue instanceof SCMAP.Faction ) {

               this[ key ] = newValue.claim( this );

            } else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

               currentValue.copy( newValue );

            } else if ( currentValue instanceof THREE.Vector3 ) {

               if ( newValue instanceof THREE.Vector3 ) {
                  currentValue.copy( newValue );
               } else if ( newValue instanceof Array ) {
                  currentValue.fromArray( newValue );
               }

            } else {

               this[ key ] = newValue;

            }
         }
      }
   }
};

SCMAP.System.preprocessSystems = function ( data ) {
   var i, systemName, system, systems = [];

   SCMAP.data.systems = {};
   SCMAP.data.systemsById = {};
   SCMAP.System.List = [];

   // First build basic objects to make them all known
   // (this will initialise any jumppoints it can as well)
   for ( systemName in data ) {
      if ( data.hasOwnProperty( systemName ) ) {
         system = SCMAP.System.fromJSON( data[ systemName ] );
         SCMAP.data.systems[ system.name ]     = system;
         SCMAP.data.systemsById[ system.id ]   = system;
         SCMAP.data.systemsById[ system.uuid ] = system;
         systems.push( system );
      }
   }

   // Now go through the built objects again, fixing any leftover jumppoint data
   $( systems ).each( function ( i, system ) {
      system._fixJumpPoints( true );
   });

   SCMAP.System.List = SCMAP.System.SortSystemList( systems );
};

SCMAP.System.List = [];

SCMAP.System.SortSystemList = function SortSystemList( systems ) {
   var array = [];
   var i = systems.length;
   while( i-- ) {
      array[i] = systems[i];
   }
   var sorted = array.sort( humanSort );
   return sorted;
};

SCMAP.System.fromJSON = function fromJSON( data ) {
   var system;

   if ( data instanceof SCMAP.System ) {
      return data;
   }

   return new SCMAP.System({
      'id': data.systemId,
      'uuid': data.uuid,
      'name': data.name,
      'position': data.coords,
      'scale': data.scale || 1.0,
      'color': data.color,
      'faction': SCMAP.Faction.getById( data.factionId ),
      'isMajorTradeHub': data.isMajorTradeHub,
      'hasWarning': data.hasWarning,
      'isOffLimits': data.isOffLimits,
      'nickname': data.nickname,
      'size': data.size,
      'info': data.info,
      'status': data.status,
      'crimeStatus': SCMAP.data.crimeLevels[ data.crimeLevel ],
      'ueeStrategicValue': SCMAP.data.ueeStrategicValues[ ""+data.ueeStrategicValue ],
      'import': data.import,
      'export': data.export,
      'blackMarket': data.blackMarket,
      'planets': [], // TODO
      'planetaryRotation': [], // TODO
      'jumpPoints': data.jumpPoints
   });
};

SCMAP.System.getByName = function getByName( name ) {
   return SCMAP.data.systems[ name ];
};

SCMAP.System.getById = function getById( id ) {
   return SCMAP.data.systemsById[ id ];
};

SCMAP.Color = {};
SCMAP.Color.BLACK = new THREE.Color( 'black' );
SCMAP.Color.UNSET = new THREE.Color( 0x80A0CC );

SCMAP.System.COLORS = {
   RED: 0xFF6060,
   BLUE: 0x6060FF,
   WHITE: 0xFFFFFF,
   YELLOW: 0xFFFF60,
   ORANGE: 0xF0F080,
   UNKNOWN: 0xFFFFFF //0xC0FFC0
};
SCMAP.System.LABEL_SCALE = 5;
SCMAP.System.GLOW_SCALE = 5.5;
SCMAP.System.UNKNOWN_SYSTEM_SCALE = 0.65;

SCMAP.System.STAR_LOD_MESHES = [
   [ new THREE.IcosahedronGeometry( 1, 3 ),  20 ],
   [ new THREE.IcosahedronGeometry( 1, 2 ), 150 ],
   [ new THREE.IcosahedronGeometry( 1, 1 ), 250 ],
   [ new THREE.IcosahedronGeometry( 1, 0 ), 500 ]
];

SCMAP.System.STAR_MATERIAL = new THREE.MeshBasicMaterial({ color: SCMAP.System.COLORS.WHITE, name: 'STAR_MATERIAL' });

SCMAP.System.INTERACTABLE_DEBUG_MATERIAL = new THREE.MeshBasicMaterial();
SCMAP.System.INTERACTABLE_DEBUG_MATERIAL.color = 0xFFFF00;
SCMAP.System.INTERACTABLE_DEBUG_MATERIAL.depthWrite = false;
SCMAP.System.INTERACTABLE_DEBUG_MATERIAL.map = null;
SCMAP.System.INTERACTABLE_DEBUG_MATERIAL.blending = THREE.AdditiveBlending;

SCMAP.System.GLOW_MAP = new THREE.ImageUtils.loadTexture( $('#sc-map-configuration').data('glow-image') );

// create custom material from the shader code in the html
//$(function() {
//   SCMAP.System.GLOW_SHADER_MATERIAL = new THREE.ShaderMaterial({
//      uniforms: { 
//         "c":   { type: "f", value: 0.05 },
//         "p":   { type: "f", value: 3.3 },
//         glowColor: { type: "c", value: SCMAP.Color.BLACK },
//         viewVector: { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) }
//      },
//      vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
//      fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
//      side: THREE.BackSide,
//      blending: THREE.AdditiveBlending,
//      transparent: true
//   });
//});

// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.Dijkstra = function ( systems, start, end ) {
   if ( ! ( typeof systems === 'object' && Array.isArray( systems ) ) ) {
      console.error( "No array specified to SCMAP.Dijkstra constructor!" );
      return;
   }

   this.start = ( start instanceof SCMAP.System ) ? start : null;
   this.end = ( this.start && end instanceof SCMAP.System ) ? end : null;

   // First build a list of all nodes in the graph and
   // map them by system.id so they can be found quickly
   this._nodes = [];
   this._mapping = {}; // system.id to _nodes map
   i = systems.length;
   while( i-- ) {
      this._nodes[ i ] = {
         system:   systems[i],
         distance: Number.POSITIVE_INFINITY,
         previous: null
      };
      this._mapping[ systems[i].id ] = this._nodes[ i ];
   }

   this._result = {};
};

SCMAP.Dijkstra.prototype = {
   constructor: SCMAP.Dijkstra,

   buildGraph: function buildGraph( priority, forceUpdate ) {
      var nodes, i, distance, system, currentNode, jumpPoint,
         otherNode, endTime, startTime = new Date();
      var distAU;

      if ( !( this.start instanceof SCMAP.System ) ) { throw new Error( "No source given" ); }
      if ( !( this.end instanceof SCMAP.System )   ) { throw new Error( "No or invalid destination given" ); }

      this._result.destination = this.end;
      // TODO: expiry, map may have changed
      if ( !forceUpdate && this._result.source instanceof SCMAP.System && this._result.source === this.start && this._result.priority === priority ) {
         //console.log( 'Reusing generated graph starting at', this._result.source.name );
         /////this._result.destination = this.end;
         return;
      }

      this.destroyGraph();
      this._result.source = this.start;
      this._result.destination = this.end;
      this._result.priority = priority;

      // Created using http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Pseudocode

      for ( i = 0; i < this._nodes.length; i++ ) {
         this._nodes[ i ].distance = Number.POSITIVE_INFINITY;
         this._nodes[ i ].previous = null;
      }

      currentNode = this._mapping[ this.start.id ];
      currentNode.distance = 0; // distance from source to source
      currentNode.previous = null;

      nodes = SCMAP.Dijkstra.quickSort( this._nodes );

      while ( nodes.length )
      {
         currentNode = nodes[0];

         // "If we are only interested in a shortest path between vertices source and
         //  target, we can terminate the search at line 13 if u = target."
         if ( currentNode.system === this.end ) {
            break;
         }

         // Remove currentNode (the first node) from set
         nodes.splice( 0, 1 );

         // Don't bother with th current node if it's not reachable
         if ( isInfinite( currentNode.distance ) ) {
            break;
         }

         //console.log( "Working on node", currentNode.system.name, ', ', currentNode.system.jumpPoints.length, 'jumppoints to test' );

         for ( i = 0; i < currentNode.system.jumpPoints.length; i++ )
         {
            jumpPoint = currentNode.system.jumpPoints[i];
            otherNode = this._mapping[ jumpPoint.destination.id ];

            // Don't take "unknown" and "undiscovered" jump points
            if ( jumpPoint.isUnconfirmed() && SCMAP.settings.route.avoidUnknownJumppoints ) {
               continue;
            }

            // These checks are only done if they're not an explicit part of the route we're building
            // (which is essentially the user overriding the route)
            if ( !this.isStartOrEnd( otherNode.system ) )
            {
               // Don't go into "hostile" nodes, unless we already are in one
               if ( SCMAP.settings.route.avoidHostile &&
                    !currentNode.system.faction.isHostileTo( SCMAP.usersFaction() ) &&
                    otherNode.system.faction.isHostileTo( SCMAP.usersFaction() )
               ) {
                  continue;
               }

               // Don't go into "off limits" nodes
               if ( SCMAP.settings.route.avoidOffLimits && otherNode.system.isOffLimits ) {
                  continue;
               }

               // Don't go into "avoid" nodes, unless we already are in one
               if ( !currentNode.system.isToBeAvoided() && otherNode.system.isToBeAvoided() ) {
                  continue;
               }
            }

            // cost = half time to JP + JP time + half time from JP
            // TODO: at start and end this can be from start and to dest rather than half
            distance = currentNode.distance + jumpPoint.jumpTime();

            if ( currentNode.previous === null ) {
               distance += SCMAP.travelTimeAU( 0.35 ); // FIXME
               //distance += SCMAP.travelTimeAU( jumpPoint.entryAU.length() ); // FIXME
               //console.log( '    Flight time to JP entrance is', SCMAP.travelTimeAU( distAU ), 's' );
            }
            else
            {
               distance += SCMAP.travelTimeAU( 0.7 );
               //distAU = currentNode.previous.system.jumpPointTo( currentNode.system ).entryAU.length();
               //console.log( '    AU from', currentNode.previous.system.name, 'to', currentNode.system.name, 'is', distAU.toFixed(2) );
               //console.log( "would add", SCMAP.travelTimeAU( currentNode.previous.system.jumpPointTo( currentNode.system ).entryAU.length() ).toFixed( 1 ) );
            }

            // Get out of "never" nodes asap by increasing the cost massively
            if ( SCMAP.settings.route.avoidHostile && otherNode.system.faction.isHostileTo( SCMAP.usersFaction() ) ) {
               distance *= 15;
            }

            if ( distance < otherNode.distance ) {
               otherNode.distance = distance;
               otherNode.previous = currentNode;
               nodes = SCMAP.Dijkstra.quickSort( nodes );
            }
         }
      }

      this._result.nodes = nodes;
      this._result.priority = priority;
      endTime = new Date();
      //console.log( 'Graph building took ' + (endTime.getTime() - startTime.getTime()) + ' msec' );
   },

   isStartOrEnd: function isStartOrEnd( system ) {
      if ( !( system instanceof SCMAP.System ) ) {
         return false;
      }
      return( system === this.start || system === this.end );
   },

   firstNode: function firstNode() {
      var routeArray = this.routeArray();
      return routeArray[ 0 ];
   },

   lastNode: function firstNode() {
      var routeArray = this.routeArray();
      return routeArray[ routeArray.length - 1 ];
   },

   source: function source() {
      if ( this.start instanceof SCMAP.System ) {
         return this.start;
      }
   },

   destination: function destination() {
      if ( this.end instanceof SCMAP.System ) {
         return this.end;
      }
   },

   rebuildGraph: function rebuildGraph() {
      //console.log( "rebuildGraph from", source, 'to', destination );
      this.destroyGraph();

      if ( this.start instanceof SCMAP.System ) {
         this.buildGraph( 'time', true );
         return true;
      }
   },

   destroyGraph: function destroyGraph() {
      this._result = {};
   },

   routeArray: function routeArray( destination ) {
      if ( ! ( destination instanceof SCMAP.System ) ) {
         if ( ! ( this._result.destination instanceof SCMAP.System ) ) {
            console.error( 'No or invalid destination specified.' );
            return;
         }
         destination = this._result.destination;
      }

      if ( this._result.nodes.length > 0 ) {
         // Get path and print it out, we're traversing backwards
         // through the optimal path for the destination
         var visited = [];
         var x = this._mapping[ destination.id ];
         var seen = {};
         while ( x !== null ) {
            seen[ x.system.name ] = true;
            visited.push( x );
            x = x.previous;
         }
         visited.reverse();
         return visited;
      }
   }
};

SCMAP.Dijkstra.quickSort = function quickSort( nodes ) {
   // makes a copy, prevents overwriting
   var array = [];
   var i = nodes.length;
   while( i-- ) {
      array[i] = nodes[i];
   }

   if ( array.length <= 1 ) {
      return array;
   }

   var lhs = [];
   var rhs = [];
   var pivot = Math.ceil( array.length / 2 ) - 1;

   pivot = array.splice( pivot, 1 )[0];

   for ( i = 0; i < array.length; i++ ) {
      if ( array[i].distance <= pivot.distance ) {
         lhs.push( array[i] );
      } else {
         rhs.push( array[i] );
      }
   }

   var t1 = SCMAP.Dijkstra.quickSort( lhs );
   var t2 = SCMAP.Dijkstra.quickSort( rhs );

   t1.push( pivot );
   return t1.concat( t2 );
};

function isInfinite ( num ) {
   return !isFinite( num );
}

// End of file


/**
  * @author Lianna Eeftinck / https://github.com/Leeft
  */

SCMAP.Route = function ( start, waypoints ) {
   this.start = ( start instanceof SCMAP.System ) ? start : null;
   this.waypoints = [];

   this._graphs = [];
   this._routeObject = undefined;

   this._error = undefined;

   if ( waypoints instanceof SCMAP.System ) {
      this.waypoints = [ waypoints ];
   } else if ( Array.isArray( waypoints ) ) {
      for ( var i = 0, waypointsLength = waypoints.length; i < waypointsLength; i += 1 ) {
         if ( waypoints[i] instanceof SCMAP.System ) {
            this.waypoints.push( waypoints[i] );
         }
      }
   }

   this.__syncGraphs();
};

SCMAP.Route.prototype = {
   constructor: SCMAP.Route,

   // Find the first matching graph or pair of graphs for the given
   // waypoint. Returns two graphs if the waypoint lies on the end
   // of one and the start of another
   __findGraphs: function __findGraphs( waypoint ) {
      var graphs = [];
      var seen = {};

      for ( var i = 0, graphsLength = this._graphs.length; i < graphsLength; i += 1 )
      {
         var route = [];
         try {
            route = this._graphs[i].routeArray();
         } catch ( e ) {
            console.error( "Error getting route array: "+e.message );
         }

         if ( graphs.length ) {
            if ( route[0].system.id === waypoint.id ) {
               graphs.push( this._graphs[i] );
               return graphs;
            }
         }

         for ( var j = 0, routeLength = route.length; j < routeLength; j += 1 ) {
            if ( route[j].system === waypoint && !(seen[ route[j].system.id ]) ) {
               seen[ route[j].system.id ] = true;
               graphs.push( this._graphs[i] );
            }
         }
      }

      return graphs;
   },

   splitAt: function splitAt( waypoint ) {
      var graphs = this.__findGraphs( waypoint );
      if ( graphs.length > 1 ) {
         console.error( "Can't split at '"+waypoint.name+"', graphs are already split" );
         return false;
      }
      if ( graphs.length !== 1 ) {
         console.error( "Couldn't find graph for waypoint '"+waypoint.name+"'" );
         return false;
      }
      var graph = graphs[0];
      var routeArray = graph.routeArray();
      var oldEnd = graph.lastNode().system;
      graph.end = waypoint; // set end of graph to wp
      for ( var i = 0, graphsLength = this._graphs.length; i < graphsLength; i += 1 )
      {
         if ( this._graphs[i] === graph ) {
            // insert new graph at wp, starting at wp, ending at oldEnd
            this._graphs.splice( i + 1, 0, new SCMAP.Dijkstra( SCMAP.System.List, waypoint, oldEnd ) );
            for ( var j = 0; j < this.waypoints.length; j += 1 ) {
               if ( this.waypoints[j] === oldEnd ) {
                  this.waypoints.splice( j, 0, waypoint );
                  break;
               }
            }
            this.__syncGraphs();
            this.storeToSession();
            return true;
         }
      }

      console.error( "Couldn't match graph to split" );
   },

   toString: function toString() {
      var result = [];
      if ( this.start instanceof SCMAP.System ) {
         result.push( this.start.toString() );
      }
      $.each( this.waypoints, function( index, value ) {
         if ( value instanceof SCMAP.System ) {
            result.push( value );
         }
      });
      return result.join( ' > ' );
   },

   removeWaypoint: function removeWaypoint( waypoint ) {
      var graphs = this.__findGraphs( waypoint );
      if ( graphs.length !== 2 ) {
         console.error( "Can't remove waypoint '"+waypoint.name+"', it is not a waypoint" );
         return false;
      }
      var graphOne = graphs[0];
      var graphTwo = graphs[1];
      graphOne.end = graphTwo.start;
      // And now delete graphTwo
      for ( var i = 0, graphsLength = this._graphs.length; i < graphsLength; i += 1 )
      {
         if ( this._graphs[i] === graphTwo ) {
            console.log( "Matched "+graphTwo+" starting at index "+i );
            console.log( this._graphs );
            // remove the graph
            this._graphs.splice( i, 1 );
            console.log( this._graphs );
            for ( var j = 0; j < this.waypoints.length; j += 1 ) {
               if ( this.waypoints[j] === waypoint ) {
                  console.log( "Matched "+waypoint+" at index "+j );
                  console.log( this.waypoints );
                  this.waypoints.splice( j, 1 );
                  console.log( this.waypoints );
                  break;
               }
            }
            this.__syncGraphs();
            this.storeToSession();
            return true;
         }
      }
   },

   moveWaypoint: function moveWaypoint( waypoint, destination ) {
      var index;

      if ( waypoint === destination ) {
         return false;
      }

      if ( destination === this.start || this.waypoints.indexOf( destination ) >= 0 ) {
         return false;
      }

      // Easy case, moving start: update start and sync
      if ( waypoint === this.start ) {
         if ( this.waypoints.length !== 1 || destination !== this.waypoints[0] ) {
            this.start = destination;
            this.__syncGraphs();
            this.storeToSession();
            return true;
         } else {
            return false;
         }
      }

      // Slightly more difficult, moving any waypoint: update waypoint and sync
      index = this.waypoints.indexOf( waypoint );
      if ( index > -1 ) {
         this.waypoints[ index ] = destination;
         this.__syncGraphs();
            this.storeToSession();
         return true;
      }

      // Advanced case: split graphs at waypoint, then update waypoint and sync
      if ( this.splitAt( waypoint ) ) {
         index = this.waypoints.indexOf( waypoint );
         if ( index > -1 ) {
            this.waypoints[ index ] = destination;
            this.__syncGraphs();
            this.storeToSession();
            return true;
         }
      }

      //console.error( "Couldn't find waypoint '"+waypoint.name+"'" );
      return false;
   },

   setRoute: function setRoute() {
      var args = Array.prototype.slice.call( arguments );
      var i;
      this.start = args.shift();
      this.start = ( this.start instanceof SCMAP.System ) ? this.start : null;
      this.waypoints = [];
      if ( this.start ) {
         for ( i = 0; i < args.length; i += 1 ) {
            if ( args[i] instanceof SCMAP.System ) {
               this.waypoints.push( args[i] );
            }
         }

         for ( i = 0; i < this.waypoints.length; i += 1 ) {
            this.waypoints[i] = ( this.waypoints[i] instanceof SCMAP.System ) ? this.waypoints[i] : null;
         }
      }
      this.storeToSession();
   },

   // Updates the graphs to match the current waypoints, and recalculates
   // the graphs where needed
   __syncGraphs: function __syncGraphs() {
      var newGraphs = [];
      this._graphs = newGraphs;
      this._error = undefined;

      try {

         for ( var i = 0, waypointsLength = this.waypoints.length; i < waypointsLength; i += 1 )
         {
            var start = ( i === 0 ) ? this.start : this.waypoints[i - 1];
            var end   = this.waypoints[i];
            var graph;
            if ( this._graphs[i] instanceof SCMAP.Dijkstra ) {
               graph = this._graphs[i];
               this._graphs[i].start = start;
               this._graphs[i].end   = end;
            } else {
               graph = new SCMAP.Dijkstra( SCMAP.System.List, start, end );
            }

            graph.buildGraph( 'time', true );
            newGraphs.push( graph );

            var routeSegment = graph.routeArray();

            if ( routeSegment.length <= 1 ) {
               console.warn( "No route from "+start.name+" to "+end.name+" possible" );
               throw new RouteSegmentFailed( "No route from "+start.name+" to "+end.name+" available" );
               // TODO: could retry with fewer restrictions to indicate the user can change things
               // to make the route possible, and indicate so in the error message
            }

         }

         this._graphs = newGraphs;
         if ( newGraphs.length > 0 ) {
            console.log( "Synced and built "+newGraphs.length+" graphs" );
         }
      }
      catch ( e )
      {
         this._error = e;
         if ( !( e instanceof RouteSegmentFailed ) ) {
            console.error( "Error building route: " + e.message );
         }
      }
   },

   lastError: function lastError() {
      return this._error;
   },

   isSet: function isSet() {
      var route = this.currentRoute();
      return route.length > 1;
   },

   currentRoute: function currentRoute() {
      var route = [];
      for ( var i = 0, graphsLength = this._graphs.length; i < graphsLength; i += 1 ) {
         if ( this.waypoints[i] instanceof SCMAP.System ) {
            this._graphs[i].rebuildGraph();
            var routePart = this._graphs[i].routeArray( this.waypoints[i] );
            for ( var j = 0; j < routePart.length; j += 1 ) {
               route.push( routePart[j] );
            }
         }
      }
      return route;
   },

   // Returns a float 0.0 to 1.0 to indicate where we are in
   // the route; we can use this to establish the approximate
   // colour of the given point
   alphaOfSystem: function alphaOfSystem( system ) {
      // TODO: Combine with indexOfCurrentRoute code
      if ( ! system instanceof SCMAP.System ) {
         return 0;
      }

      var currentStep = 0;
      var currentRoute = this.currentRoute();

      if ( currentRoute.length ) {
         for ( var i = 0, routeLength = currentRoute.length; i < routeLength; i++ ) {
            if ( currentRoute[i].system === system ) {
               currentStep = i;
               break;
            }
         }
      }

      if ( currentStep ) {
         return( currentStep / currentRoute.length );
      }

      return 0;
   },

   indexOfCurrentRoute: function indexOfCurrentRoute( system ) {
      if ( ! system instanceof SCMAP.System ) {
         return;
      }

      var currentStep;
      var currentRoute = this.currentRoute();

      if ( currentRoute.length ) {
         for ( var i = 0, routeLength = currentRoute.length; i < routeLength; i++ ) {
            if ( currentRoute[i].system === system ) {
               currentStep = i;
               break;
            }
         }
      }

      return currentStep;
   },

   rebuildCurrentRoute: function rebuildCurrentRoute() {
      this.removeFromScene();
      for ( var i = 0, graphsLength = this._graphs.length; i < graphsLength; i++ ) {
         if ( this._graphs[i].rebuildGraph() ) {
            var destination = this._graphs[i].destination();
            if ( destination ) {
               console.log( "Have existing destination, updating route" );
               this.update( destination );
            }
         }
      }
   },

   destroy: function destroy() {
      this.start = null;
      this.waypoints = [];
      this.update();
   },

   removeFromScene: function removeFromScene() {
      if ( this._routeObject ) {
         scene.remove( this._routeObject );
      }
   },

   buildTemplateData: function() {
      var system, i, waypoint;
      var templateData = {
         settings: {
            avoidHostile: SCMAP.settings.route.avoidHostile,
            avoidUnknownJumppoints: SCMAP.settings.route.avoidUnknownJumppoints,
            avoidOffLimits: SCMAP.settings.route.avoidOffLimits
         },
      };
      var entireRoute = this.currentRoute();

      if ( !entireRoute.length )
      {
         if ( this.start && this.waypoints.length )
         {
            templateData.status = {
               text: 'No route available with your current settings.',
               class: 'impossible'
            };
         }
         else
         {
            templateData.status = {
               text: 'No route set',
               class: 'no-route'
            };
         }
      }
      else
      {
         templateData.from          = entireRoute[0].system;
         templateData.to            = entireRoute[entireRoute.length-1].system;
         templateData.waypoints     = [];
         templateData.totalDuration = 0;

         for ( i = 0, entireRouteLength = entireRoute.length; i < entireRouteLength; i += 1 )
         {
            system = entireRoute[i].system;

            if ( ( i > 0 ) && ( system.id === entireRoute[i-1].system.id ) )
            {
               // Duplicate waypoint, which means we jumped between routes, so update the last waypoint instead
               waypoint = templateData.waypoints[ templateData.waypoints.length - 1 ];
               waypoint.iconClass = 'fa-times text-danger';
               waypoint.iconTitle = 'Remove waypoint';
               waypoint.rowClass  = 'waypoint';
               waypoint.action    = '<a href="#" class="remove-waypoint" data-system="'+system.id+'">';
               continue;
            }

            waypoint = {
               rowClass: '',
               index: templateData.waypoints.length + 1,
               system: system,
               iconClass: 'fa-long-arrow-down',
               iconTitle: 'Jump Point',
               duration: 30 * 60,
               action: ''
            };

            if ( i === 0 ) {

               waypoint.duration = 30 * 60 / 2; // TODO
               waypoint.rowClass = 'start';
               waypoint.iconClass = 'fa-flag';
               waypoint.iconTitle = 'Start';

            } else if ( i === ( entireRoute.length - 1 ) ) {

               waypoint.duration = 30 * 60 / 2; // TODO
               waypoint.rowClass = 'end';
               waypoint.iconClass = 'fa-flag-checkered';
               waypoint.iconTitle = 'Destination';

            }

            templateData.waypoints.push( waypoint );
            templateData.totalDuration += waypoint.duration;
         }
      }

      return templateData;
   },

   update: function update() {
      var _this = this, i, route, material, system, $entry;
      var before = this.toString();
      var entireRouteLength;
      var waypointsLength;

      this.__syncGraphs();

      this.removeFromScene();

      var entireRoute = this.currentRoute();

      if ( entireRoute.length )
      {
         // Exception can be thrown and caught to signal the route isn't possible
         if ( this.lastError() ) {
            return;
         }

         destination = this.waypoints[this.waypoints.length-1];

         // Build all the parts of the route together in a single geometry group
         this._routeObject = new THREE.Object3D();
         this._routeObject.matrixAutoUpdate = false;

         var startColour = new THREE.Color( 0xEEEE66 );
         var endColour   = new THREE.Color( 0xFF3322 );

         for ( i = 0, entireRouteLength = entireRoute.length - 1; i < entireRouteLength; i += 1 ) {
            var from = entireRoute[i].system;
            var to = entireRoute[i+1].system;
            var geometry = this.createRouteGeometry( from, to );
            if ( geometry ) {
               material = new THREE.MeshBasicMaterial({ color: startColour.clone().lerp( endColour, this.alphaOfSystem( to ) ) });
               var mesh = new THREE.Mesh( geometry, material );
               mesh.position.copy( from.sceneObject.position );
               mesh.lookAt( to.sceneObject.position );
               this._routeObject.add( mesh );
            }
         }

         if ( typeof this.start.sceneObject === 'object' )
         {
            var waypointObject = window.map.createSelectorObject( startColour );
            waypointObject.scale.set( 3.8, 3.8, 3.8 );
            waypointObject.position.copy( this.start.sceneObject.position );
            waypointObject.visible = true;
            this._routeObject.add( waypointObject );

            for ( i = 0, waypointsLength = this.waypoints.length; i < waypointsLength; i += 1 ) {
               if ( typeof this.waypoints[i].sceneObject === 'object' ) {
                  waypointObject = window.map.createSelectorObject( startColour.clone().lerp( endColour, this.alphaOfSystem( this.waypoints[i] ) ) );
                  waypointObject.scale.set( 3.8, 3.8, 3.8 );
                  waypointObject.position.copy( this.waypoints[i].sceneObject.position );
                  waypointObject.visible = true;
                  this._routeObject.add( waypointObject );
               }
            }

            scene.add( this._routeObject );
         }
      }

      $( SCMAP.UI.Tab('route').id )
         .empty()
         .append( SCMAP.UI.Templates.routeList({
            route: this.buildTemplateData()
         }));

      if ( this.toString() !== before ) {
         ui.toTab( 'route' );
      }
   },

   storeToSession: function storeToSession() {
      if ( hasSessionStorage ) {
         if ( this.start && ( this.waypoints.length ) ) {
            window.sessionStorage.currentRoute = JSON.stringify({
               start: this.start.id,
               waypoints: $.map( this.waypoints, function ( waypoint, i ) {
                  return waypoint.id;
               })
            });
         } else {
            delete window.sessionStorage.currentRoute;
         }
      }
   },

   restoreFromSession: function restoreFromSession() {
      if ( hasSessionStorage && ( 'currentRoute' in window.sessionStorage ) ) {
         var data = JSON.parse( window.sessionStorage.currentRoute );
         this.start = SCMAP.System.getById( data.start );
         this.waypoints = $.map( data.waypoints, function ( waypoint, i ) {
            return SCMAP.System.getById( waypoint );
         });
         //this.update();
      }
   },

   createRouteGeometry: function createRouteGeometry( source, destination ) {
      if ( !source.sceneObject ) { return; }
      if ( !destination.sceneObject ) { return; }
      var distance = source.sceneObject.position.distanceTo( destination.sceneObject.position );
      var geometry = new THREE.CylinderGeometry( 0.6, 0.6, distance, 8, 1, true );
      geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, distance / 2, 0 ) );
      geometry.applyMatrix( new THREE.Matrix4().makeRotationX( THREE.Math.degToRad( 90 ) ) );
      return geometry;
   }
};

function RouteSegmentFailed( message ) {
   this.message = message;
   this.name = 'RouteSegmentFailed';
}
RouteSegmentFailed.prototype = new Error();
RouteSegmentFailed.prototype.constructor = RouteSegmentFailed;


// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.Map = function () {
   this.name = "Star Citizen Persistent Universe";
   this.scene = new THREE.Scene();

   // No editing available for the moment (doesn't work yet)
   this.canEdit = false;
   //$('#map_ui li.editor').hide();

   this._interactables = [];
   this._route = null; // The main route the user can set

   this._selectorObject = this.createSelectorObject( 0x99FF99 );
   this.scene.add( this._selectorObject );

   this._mouseOverObject = this.createSelectorObject( 0x8844FF );
   this._mouseOverObject.scale.set( 4.0, 4.0, 4.0 );
   this.scene.add( this._mouseOverObject );

   SCMAP.Faction.preprocessFactions( SCMAP.data.factions );
   SCMAP.Goods.preprocessGoods( SCMAP.data.goods );

   this.__currentlySelected = null;

   this.animate = this._animate.bind( this );

   var map = this;

   $.ajax({
      url: $('#sc-map-configuration').data('systems-json'),
      async: true,
      cache: true,
      dataType: 'json',
      ifModified: true,
      timeout: 5 * 1000
   })
   .done( function xhrDone( data, textStatus, jqXHR ) {
      var storage = window.sessionStorage;
      var selectedSystem;
      //console.log( "ajax done", data, textStatus, jqXHR );
      map.populate( data );
      map.scene.add( map.buildReferenceGrid() );
      window.ui.updateSystemsList();
      window.renderer.controls.idle();

      window.renderer.controls.throttledEventListener.init( 'change', function ()
      {
         var euler = new THREE.Euler( window.renderer.camera.userData.phi + Math.PI / 2, window.renderer.camera.userData.theta, 0, 'YXZ' );
         var rotationMatrix = new THREE.Matrix4().makeRotationFromEuler( euler );
         //map.scene.updateMatrixWorld();

         if ( $('#debug-camera-is-moving') ) {
            $('#debug-camera-is-moving').text( 'Camera is moving' );
         }

         window.renderer.controls.rememberPosition();

         map.scene.traverse( function ( object ) {
            if ( ( object instanceof THREE.Sprite ) && object.userData.isLabel )
            {
               object.position.copy( object.userData.position.clone().applyMatrix4( rotationMatrix ) );
            }
            else if ( object instanceof THREE.LOD )
            {
               object.update( window.renderer.camera );
            }
         });
      });

      map.route().restoreFromSession();
      map.route().update();

      if ( hasSessionStorage() && ( 'selectedSystem' in storage ) ) {
         selectedSystem = SCMAP.System.getById( storage.selectedSystem );
         if ( selectedSystem instanceof SCMAP.System ) {
            map.setSelectionTo( selectedSystem );
            selectedSystem.displayInfo( true );
         }
      }

      window.ui.updateHeight();
   })
   .fail( function xhrFail( jqXHR, textStatus, errorThrown ) {
      console.error( "Ajax request failed:", errorThrown, textStatus );
   });

   this.displayState = this.buildDisplayModeFSM( SCMAP.settings.mode );
};

SCMAP.Map.prototype = {
   constructor: SCMAP.Map,

   getSelected: function getSelected () {
      return this.__currentlySelected;
   },

   selected: function selected() {
      return this.getSelected();
   },

   _animate: function _animate() {
      var rotationY = THREE.Math.degToRad( Date.now() * 0.00025 ) * 300;
      this.scene.traverse( function ( object ) {
         if ( object.userData.isSelector ) {
            object.rotation.y = rotationY;
         }
      });
   },

   setSelected: function setSelected ( system ) {
      var storage = window.sessionStorage;
      if ( system !== null && !(system instanceof SCMAP.System) ) {
         throw new Error( system, "is not an instance of SCMAP.System" );
      }
      this.__currentlySelected = system;
      if ( hasSessionStorage() ) {
         storage.selectedSystem = system.id;
      }
      return system;
   },

   createSelectorObject: function createSelectorObject ( color ) {
      var mesh = new THREE.Mesh( SCMAP.SelectedSystemGeometry, new THREE.MeshBasicMaterial({ color: color }) );
      mesh.scale.set( 4.2, 4.2, 4.2 );
      mesh.visible = false;
      mesh.userData.systemPosition = new THREE.Vector3( 0, 0, 0 );
      mesh.userData.isSelector = true;
      // 2d/3d tween callback
      mesh.userData.scaleY = function ( object, scalar ) {
         var wantedY = object.userData.systemPosition.y * ( scalar / 100 );
         object.translateY( wantedY - object.position.y );
      };
      return mesh;
   },

   __updateSelectorObject: function __updateSelectorObject ( system ) {
      if ( system instanceof SCMAP.System ) {
         this._selectorObject.visible = true;
         this._selectorObject.userData.systemPosition.copy( system.position );
         //this._selectorObject.position.copy( system.sceneObject.position );
         this.moveSelectorTo( system );
         this.setSelected( system );
      } else {
         this._selectorObject.visible = false;
         this.setSelected( null );
      }
   },

   // Lazy builds the route
   route: function route () {
      if ( !( this._route instanceof SCMAP.Route ) ) {
         this._route = new SCMAP.Route();
         console.log( "Created new route", this._route.toString() );
      }
      return this._route;
   },

   setSelectionTo: function setSelectionTo ( system ) {
      return this.__updateSelectorObject( system );
   },

   getSystemByName: function getSystemByName ( name ) {
      return SCMAP.System.getByName( name );
   },

   interactables: function interactables () {
      return this._interactables;
   },

   deselect: function deselect () {
      return this.__updateSelectorObject();
   },

   updateSystems: function updateSystems () {
      for ( var i = 0; i < SCMAP.System.List.length; i++ ) {
         SCMAP.System.List[i].updateSceneObject( this.scene );
      }
   },

   setAllLabelSizes: function setAllLabelSizes ( vector ) {
      for ( var i = 0; i < SCMAP.System.List.length; i++ ) {
         SCMAP.System.List[i].setLabelScale( vector );
      }
   },

   moveSelectorTo: function moveSelectorTo ( destination ) {
      var tween, newPosition, position, _this = this, poi, graph, route;
      var tweens = [];

      if ( !(_this._selectorObject.visible) || !(_this.getSelected() instanceof SCMAP.System) ) {
         _this._selectorObject.userData.systemPosition.copy( destination.position );
         _this._selectorObject.position.copy( destination.sceneObject.position );
         _this._selectorObject.visible = true;
         _this.getSelected( destination );
         return;
      }

      newPosition = destination.sceneObject.position.clone();
      graph = new SCMAP.Dijkstra( SCMAP.System.List, _this.getSelected(), destination );
      graph.buildGraph();

      route = graph.routeArray( destination );
      if ( route.length <= 1 ) {
         _this._selectorObject.userData.systemPosition.copy( destination.position );
         _this._selectorObject.position.copy( destination.sceneObject.position );
         _this._selectorObject.visible = true;
         _this.setSelected( destination );
         return;
      }

      position = {
         x: _this._selectorObject.position.x,
         y: _this._selectorObject.position.y,
         z: _this._selectorObject.position.z
      };

      /* jshint ignore:start */
      for ( i = 0; i < route.length - 1; i++ ) {
         poi = route[ i + 1 ].system;

         tween = new TWEEN.Tween( position )
            .to( {
               x: poi.sceneObject.position.x,
               y: poi.sceneObject.position.y,
               z: poi.sceneObject.position.z
            }, 800 / ( route.length - 1 ) )
            .easing( TWEEN.Easing.Linear.None )
            .onUpdate( function () {
               _this._selectorObject.position.set( this.x, this.y, this.z );
            } );

         if ( i == 0 ) {
            if ( route.length == 2 ) {
               tween.easing( TWEEN.Easing.Cubic.InOut );
            } else {
               tween.easing( TWEEN.Easing.Cubic.In );
            }
         }

         if ( i > 0 ) {
            tweens[ i - 1 ].chain( tween );
         }

         if ( i == route.length - 2 ) {
            tween.easing( TWEEN.Easing.Cubic.Out );
            tween.onComplete( function() {
               _this._selectorObject.userData.systemPosition.copy( poi.position );
               _this._selectorObject.position.copy( poi.sceneObject.position );
               _this.setSelected( destination );
            } );
         }

         tweens.push( tween );
      }
      /* jshint ignore:end */

      tweens[0].start();
   },

   populate: function populate( data ) {
      var jumpPointObject, endTime, startTime, systemCount = 0, i, map = this;

      endTime = startTime = new Date();

      SCMAP.System.preprocessSystems( data );

      // TODO: clean up the existing scene and map data when populating with
      // new data

      // First we go through the data to build the basic systems so
      // the routes can be built as well

      $( SCMAP.System.List ).each( function( index, system ) {
         var sceneObject = system.buildSceneObject();
         map.scene.add( sceneObject );
         map._interactables.push( sceneObject.userData.interactable );
         systemCount++;
         system.sceneObject = sceneObject;
      });

      // Then we go through again and add the routes

      $( SCMAP.System.List ).each( function( index, system ) {
         for ( i = 0; i < system.jumpPoints.length; i ++ ) {
            jumpPointObject = system.jumpPoints[i].buildSceneObject();
            if ( jumpPointObject instanceof THREE.Object3D ) {
               system._routeObjects.push( jumpPointObject );
               map.scene.add( jumpPointObject );
            }
         }
      });

      endTime = new Date();
      console.log( "Populating the scene (without ref plane) took " +
         (endTime.getTime() - startTime.getTime()) + " msec" );

      $('#debug-systems').html( systemCount + ' systems loaded' );

      var _this = this;
      SCMAP.UI.waitForFontAwesome( function() { _this.updateSystems(); } );
   },

   closestPOI: function closestPOI ( vector ) {
      var closest = Infinity, _closestPOI, system, length, systemname, xd, zd;

      for ( systemname in SCMAP.data.systems ) {
         system = SCMAP.System.getByName( systemname );
         xd = vector.x - system.position.x;
         zd = vector.z - system.position.z;
         length = Math.sqrt( xd * xd + zd * zd );
         if ( length < closest ) {
            closest = length;
            _closestPOI = system;
         }
      }

      return [ closest, _closestPOI ];
   },

   closestFromArray: function closestFromArray ( vector, systems ) {
      var closest = Infinity, closestPOI, system, length, systemname, xd, zd;

      for ( var i = 0; i < systems.length; i++ ) {
         system = systems[i];
         xd = vector.x - system.position.x;
         zd = vector.z - system.position.z;
         length = Math.sqrt( xd * xd + zd * zd );
         if ( length < closest ) {
            closest = length;
            closestPOI = system;
         }
      }

      return [ closest, closestPOI ];
   },

   // Get a quick list of systems nearby (within a square)
   withinApproxDistance: function withinApproxDistance ( vector, distance ) {
      var systems = [];
      for ( var i = 0; i < SCMAP.System.List.length; i += 1 ) {
         var system = SCMAP.System.List[i];
         if ( system.position.x < ( vector.x - distance ) ) { continue; }
         if ( system.position.x > ( vector.x + distance ) ) { continue; }
         if ( system.position.z < ( vector.z - distance ) ) { continue; }
         if ( system.position.z > ( vector.z + distance ) ) { continue; }
         systems.push( system );
      }
      return systems;
   },

   furthestPOI: function furthestPOI ( vector ) {
      var furthest = 0, _furthestPOI, system, length, systemname, xd, zd;

      for ( systemname in SCMAP.data.systems ) {
         system = SCMAP.System.getByName[ systemname ];
         xd = vector.x - system.position.x;
         zd = vector.z - system.position.z;
         length = Math.sqrt( xd * xd + zd * zd );
         if ( length > furthest ) {
            furthest = length;
            _furthestPOI = system;
         }
      }
      return [ furthest, _furthestPOI ];
   },

   pointAtPlane: function pointAtPlane( theta, radius, y ) {
      return new THREE.Vector3( radius * Math.cos( theta ), y, -radius * Math.sin( theta ) );
   },

   buildReferenceGrid: function buildReferenceGrid() {
      var segmentSize = 10, i, j, k, x, z, position;
      var minX = 0, minZ = 0, maxX = 0, maxZ = 0;
      var endTime, startTime;
      var uniqueColours = {};
      var left, right, above, below;
      var vertices, vertexColours;
      var geo = new THREE.BufferGeometry();
      var color;
      var grid = {};
      var alongX = {};

      endTime = startTime = new Date();

      // First we compute rough outer bounds based on all the systems on the map
      // (plus a bit extra because we want to fade to black as well)
      for ( i = 0; i < SCMAP.System.List.length; i += 1 ) {
         position = SCMAP.System.List[i].position;
         if ( position.x < minX ) { minX = position.x - (  6 * 10 ); }
         if ( position.x > maxX ) { maxX = position.x + (  8 * 10 ); }
         if ( position.z < minZ ) { minZ = position.z - (  6 * 10 ); }
         if ( position.z > maxZ ) { maxZ = position.z + ( 10 * 10 ); }
      }

      // Now round those numbers to a multiple of segmentSize
      minX = Math.floor( minX / segmentSize ) * segmentSize;
      minZ = Math.floor( minZ / segmentSize ) * segmentSize;
      maxX = Math.floor( maxX / segmentSize ) * segmentSize;
      maxZ = Math.floor( maxZ / segmentSize ) * segmentSize;

      // With the boundaries established, go through each coordinate
      // on the map, and set the colour for each gridpoint on the
      // map with the nearest system's faction being used for that
      // colour. We also take note of each X coordinate visited.
      // There is a bit of room for optimisation left here; the
      // systems could be sorted by a X or Z coordinate, sort of like
      // in an octree, and could possibly be found quicker that way.
      for ( var iz = minZ; iz <= maxZ; iz += segmentSize ) {

         grid[ iz ] = {};

         for ( var ix = minX; ix <= maxX; ix += segmentSize ) {

            alongX[ ix ] = true;

            var vector = new THREE.Vector3( ix, 0, iz );
            var systems = this.withinApproxDistance( vector, 6.5 * segmentSize );

            color = this.colorForVector( vector, systems, segmentSize );

            if ( color !== SCMAP.Map.BLACK )
            {
               grid[ iz ][ ix ] = color.getHexString();
               if ( uniqueColours[ grid[iz][ix] ] === undefined ) {
                  uniqueColours[ grid[iz][ix] ] = color;
               }
            }
            else
            {
               grid[ iz ][ ix ] = null;
               uniqueColours[ null ] = SCMAP.Map.BLACK;
            }

         }

      }

      // Now for both X and Z we build a sorted list of each of
      // those coordinates seen, allowing for quick iteration.
      var alongX2 = []; for ( j in alongX ) { alongX2.push( j ); }
      alongX2.sort( function ( a, b ) { return a - b; } );
      alongX = alongX2;

      var alongZ = []; for ( j in grid ) { alongZ.push( j ); }
      alongZ.sort( function ( a, b ) { return a - b; } );

      var positions = [];
      var next_positions_index = 0;
      var colors = [];
      var indices_array = [];

      function addLine( v1, c1, v2, c2 ) {
         if ( next_positions_index >= 0xfffe ) {
            throw new Error("Too many points");
         }

         positions.push( v1[0], v1[1], v1[2] );
         colors.push( c1.r, c1.g, c1.b );
         next_positions_index++;

         positions.push( v2[0], v2[1], v2[2] );
         colors.push( c2.r, c2.g, c2.b );

         indices_array.push( next_positions_index - 1, next_positions_index );

         return next_positions_index++;
      }

      // Now we got most data worked out, and we can start drawing
      // the horizontal lines. We draw a line from start vertex to
      // end vertex for each section where the colour doesn't
      // change. This gives us the fewest number of lines drawn.
      for ( i = 1; i < alongZ.length; i += 1 ) {
         z = alongZ[i];
         vertices = [];
         vertexColours = [];

         for ( j = 1; j < alongX.length; j += 1 ) {
            x = alongX[ j ];
            left = Math.floor( Number( x ) - segmentSize );
            right = Math.floor( Number( x ) + segmentSize );

            vertexColor = grid[ z ][ x ];

            if ( (vertexColor !== grid[z][left]  && grid[z][left] ) ||
                 (vertexColor !== grid[z][right] && grid[z][right])    )
            {
               vertices.push( [ x, 0, z ] );
               vertexColours.push( uniqueColours[ vertexColor ] );
            }
         }

         for ( k = 0; k < vertices.length - 1; k++ ) {
            addLine( vertices[k], vertexColours[k], vertices[k+1], vertexColours[k+1] );
         }
      }

      // And do the same for the vertical lines in a separate pass
      for ( i = 1; i < alongX.length; i += 1 ) {
         x = alongX[i];
         vertices = [];
         vertexColours = [];

         for ( j = 1; j < alongZ.length; j += 1 ) {
            z = alongZ[j];
            above = Math.floor( Number( z ) - segmentSize );
            below = Math.floor( Number( z ) + segmentSize );

            vertexColor = grid[ z ][ x ];

            if ( ( grid[above] && grid[above][x] && vertexColor !== grid[above][x] ) ||
                 ( grid[below] && grid[below][x] && vertexColor !== grid[below][x] )    )
            {
               vertices.push( [ x, 0, z ] );
               vertexColours.push( uniqueColours[ vertexColor ] );
            }
         }

         for ( k = 0; k < vertices.length - 1; k++ ) {
            addLine( vertices[k], vertexColours[k], vertices[k+1], vertexColours[k+1] );
         }
      }

// TODO FIXME: current r67 master branch doesn't allow parameters in the constructor, dev branch does ... this code should work for both but needs updating when it is in master
var indexBA = new THREE.BufferAttribute();
indexBA.array = new Uint16Array( indices_array );
indexBA.itemSize = 1;
geo.addAttribute( 'index', indexBA );

indexBA = new THREE.BufferAttribute();
indexBA.array = new Float32Array( positions );
indexBA.itemSize = 3;
geo.addAttribute( 'position', indexBA );

indexBA = new THREE.BufferAttribute();
indexBA.array = new Float32Array( colors );
indexBA.itemSize = 3;
geo.addAttribute( 'color', indexBA );

      geo.dynamic = false;
      geo.computeBoundingBox();

      // Finally create the object with the geometry just built
      var referenceLines = new THREE.Line( geo, new THREE.LineBasicMaterial({
         linewidth: 1.5, wireframe: true, vertexColors: THREE.VertexColors
      }), THREE.LinePieces );

      referenceLines.matrixAutoUpdate = false;

      endTime = new Date();
      console.log( "Building the grid reference plane took " +
         (endTime.getTime() - startTime.getTime()) + " msec" );

      return referenceLines;
   },

   colorForVector: function colorForVector( vector, systems, segmentSize ) {
      var color = SCMAP.Map.BLACK;
      var arr = this.closestFromArray( vector, systems );
      if ( arr[0] <= 4.5 * segmentSize && arr[1] ) {
         color = arr[1].faction.planeColor.clone();
         if ( arr[0] >= 4.0 * segmentSize ) {
            color.multiplyScalar( 0.5 );
         } else if ( arr[0] >= 3.0 * segmentSize ) {
            color.multiplyScalar( 0.8 );
         }
      }
      return color;
   },

   buildDisplayModeFSM: function buildDisplayModeFSM ( initialState ) {
      var tweenTo2d, tweenTo3d, position, fsm;
      var map = this;

      position = { y: ( initialState === '3d' ) ? 100 : 0.5 };

      tweenTo2d = new TWEEN.Tween( position )
         .to( { y: 0.5 }, 1000 )
         .easing( TWEEN.Easing.Cubic.InOut )
         .onUpdate( function () {
            map.route().removeFromScene(); // TODO: find a way to animate
            for ( var i = 0; i < map.scene.children.length; i++ ) {
               var child = map.scene.children[i];
               if ( typeof child.userData.scaleY === 'function' ) {
                  child.userData.scaleY( child, this.y );
               }
            }
         } );

      tweenTo3d = new TWEEN.Tween( position )
         .to( { y: 100.0 }, 1000 )
         .easing( TWEEN.Easing.Cubic.InOut )
         .onUpdate( function () {
            map.route().removeFromScene(); // TODO: find a way to animate
            for ( var i = 0; i < map.scene.children.length; i++ ) {
               var child = map.scene.children[i];
               if ( typeof child.userData.scaleY === 'function' ) {
                  child.userData.scaleY( child, this.y );
               }
            }
         } );

      fsm = StateMachine.create({
         initial: initialState || '3d',

         events: [
            { name: 'to2d',  from: '3d', to: '2d' },
            { name: 'to3d', from: '2d', to: '3d' }
         ],

         callbacks: {
            onenter2d: function() {
               $('#sc-map-3d-mode').prop( 'checked', false );
               if ( storage ) { storage.mode = '2d'; }
            },

            onenter3d: function() {
               $('#sc-map-3d-mode').prop( 'checked', true );
               if ( storage ) { storage.mode = '3d'; }
            },

            onleave2d: function() {
               tweenTo3d.onComplete( function() {
                  fsm.transition();
                  map.route().update();
               });
               tweenTo3d.start();
               return StateMachine.ASYNC;
            },

            onleave3d: function() {
               tweenTo2d.onComplete( function() {
                  fsm.transition();
                  map.route().update();
               });
               tweenTo2d.start();
               return StateMachine.ASYNC;
            },
         },

         error: function( eventName, from, to, args, errorCode, errorMessage ) {
            console.log( 'event ' + eventName + ' was naughty : ' + errorMessage );
         }
      });

      return fsm;
   }
};

SCMAP.Map.BLACK = new THREE.Color( 0x000000 );

// EOF

/**
  * @author Lianna Eeftinck / https://github.com/Leeft
  */
SCMAP.UI = function ( map ) {

   var me = this;

   var selectedSystem = null;
   if ( hasSessionStorage() && ( 'selectedSystem' in window.sessionStorage ) ) {
      selectedSystem = SCMAP.System.getById( window.sessionStorage.selectedSystem );
      if ( selectedSystem instanceof SCMAP.System ) {
         map.setSelectionTo( selectedSystem );
      } else {
         selectedSystem = null;
      }
   }

   this.map = map;

   var icons = [];
   for ( var icon in SCMAP.Symbols ) {
      icon = SCMAP.Symbols[ icon ];
      icons.push( $('<span><i class="fa-li fa '+icon.faClass+'"></i>'+icon.description+'</span>' ).css( 'color', icon.color ).outerHtml() );
   }

   $('#sc-map-interface').empty().append(
      SCMAP.UI.Templates.mapUI({
         instructions: [
            "Left-click and release to select a system.",
            "Left-click and drag from system to system to map a route between them.",
            "Left-click and drag any waypoint on the route to move it. It moves an existing waypoint or creates new waypoints as needed.",
            "Left-click and drag on the map to rotate the camera around the center of the map.",
            "Mousewheel to zoom in and out, middle-click and drag can also be used.",
            "Right-click to pan the camera around the map."
         ],
         shortcuts: [
            { key: "R",   description: "Reset camera orientation" },
            { key: "C",   description: "Camera to center (Sol)" },
            { key: "T",   description: "Top-down camera" },
            { key: "L",   description: "Lock/unlock camera rotation" },
            { key: "2",   description: "Switch to 2D mode" },
            { key: "3",   description: "Switch to 3D mode" },
            { key: "Esc", description: "Deselect target" }
         ],
         icons: icons,
         systemGroups: SCMAP.UI.buildDynamicLists(),
         system: selectedSystem,
         settings: {
            glow: SCMAP.settings.glow,
            labels: SCMAP.settings.labels,
            labelIcons: SCMAP.settings.labelIcons,
            effect: {
               Antialias: SCMAP.settings.effect.Antialias,
               FXAA: SCMAP.settings.effect.FXAA,
               Bloom: SCMAP.settings.effect.Bloom
            }
         },
         route: map.route().buildTemplateData()
      })
   );
   $( SCMAP.UI.menuBar ).each( function ( i, menuItem ) {
      $('#sc-map-interface ul.menubar').append( menuItem );
   });

   $('#sc-map-3d-mode')
      .prop( 'checked', SCMAP.settings.mode === '3d' )
      .on( 'change', function() {
         if ( this.checked ) {
            me.map.displayState.to3d();
         } else {
            me.map.displayState.to2d();
         }
      });

   $('#sc-map-lock-rotation')
      .prop( 'checked', SCMAP.settings.control.rotationLocked )
      .on( 'change', function() {
         renderer.controls.noRotate = this.checked;
         if ( storage ) {
            storage['control.rotationLocked'] = ( this.checked ) ? '1' : '0';
         }
      });

   $('#sc-map-resetCamera').on( 'click', function() {
      renderer.controls.cameraTo(
         SCMAP.settings.cameraDefaults.target,
         SCMAP.settings.cameraDefaults.orientation.theta,
         SCMAP.settings.cameraDefaults.orientation.phi,
         SCMAP.settings.cameraDefaults.orientation.radius
      );
   });

   $('#sc-map-centreCamera').on( 'click', function() {
      renderer.controls.moveTo( SCMAP.settings.cameraDefaults.target );
   });

   $('#sc-map-northCamera').on( 'click', function() {
      renderer.controls.rotateTo( 0, undefined, undefined );
   });

   $('#sc-map-topCamera').on( 'click', function() {
      renderer.controls.rotateTo( 0, 0, 180 );
   });

   $('#sc-map-top2D').on( 'click', function() {
      renderer.controls.noRotate = true;
      $('#sc-map-lock-rotation').prop( 'checked', true );
      me.map.displayState.to2d();
      renderer.controls.rotateTo( 0, 0, 180 );
   });

   var tabIndex = 0;
   if ( hasSessionStorage() && ( 'scMapTab' in window.sessionStorage ) ) {
      var defaultTab = SCMAP.UI.Tab( window.sessionStorage.scMapTab );
      if ( defaultTab ) {
         tabIndex = defaultTab.index;
      }
   }

   $("#sc-map-interface").tabs({
      active: tabIndex,
      activate: function( event, ui ) {
         event.preventDefault();
         var clicked_on = ui.newTab.find('a').data('tab');
         var tab = SCMAP.UI.Tab( clicked_on );

         switch ( clicked_on ) {

            case 'systems':
               me.updateSystemsList();
               break;

            default:
               $('#sc-map-webgl-container').removeClass('edit');
               //window.editor.enabled = false;
               //window.controls.requireAlt = false;
               //if ( clicked_on === '#info' && map.selected() instanceof SCMAP.System ) {
               //   map.selected().displayInfo();
               //}
               break;
         }

         if ( hasSessionStorage() ) {
            window.sessionStorage.scMapTab = clicked_on;
         }

         /* Browsers show an ugly URL bar if href is set to #, this
         * makes the HTML invalid but removes the ugly URL bar */
         $("#sc-map-interface a[href='#']").removeAttr('href');

         me.updateHeight();
         me.toTabTop();
      }
   });

   $('#sc-map-toggle-glow').prop( 'checked', SCMAP.settings.glow );
   $('#sc-map-toggle-labels').prop( 'checked', SCMAP.settings.labels );
   $('#sc-map-toggle-label-icons').prop( 'checked', SCMAP.settings.labelIcons );

   // Some simple UI stuff

   $('#sc-map-interface').on( 'change', '.sc-map-avoid-hostile', function() {
      SCMAP.settings.route.avoidHostile = this.checked;
      SCMAP.settings.save( 'route' );
      map.route().update();
      map.route().storeToSession();
   });

   $('#sc-map-interface').on( 'change', '.sc-map-avoid-unknown-jumppoints', function() {
      SCMAP.settings.route.avoidUnknownJumppoints = this.checked;
      SCMAP.settings.save( 'route' );
      map.route().update();
      map.route().storeToSession();
   });

   $('#sc-map-interface').on( 'change', '.sc-map-avoid-off-limits', function() {
      SCMAP.settings.route.avoidOffLimits = this.checked;
      SCMAP.settings.save( 'route' );
      map.route().update();
      map.route().storeToSession();
   });

   // UI width slider / settings handling
   //
   if ( hasSessionStorage() )
   {
      window.sessionStorage.uiWidth = SCMAP.UI.widthClasses[ SCMAP.UI.widthClassToIndex( window.sessionStorage.uiWidth ) ];
      $('#sc-map-interface')
         .removeClass( SCMAP.UI.widthClasses.join(' ') )
         .addClass( window.sessionStorage.uiWidth );
   }
   //
   $('#sc-map-interface .sc-map-slider-uiwidth').slider({
      min: 0,
      max: SCMAP.UI.widthClasses.length - 1,
      range: 'min',
      value: ( hasSessionStorage() ) ? SCMAP.UI.widthClassToIndex( window.sessionStorage.uiWidth ) : SCMAP.UI.defaultWidthIndex,
      change: function ( event, ui ) {
         var value = ui.value;
         $('#sc-map-interface').removeClass( SCMAP.UI.widthClasses.join(' ') ).addClass( SCMAP.UI.widthClasses[ value ] );
         if ( hasSessionStorage() ) {
            window.sessionStorage.uiWidth = SCMAP.UI.widthClasses[ value ];
         }
         me.updateHeight();
         renderer.resize();
      }
   });

   var updateLabelSize = function( event, ui ) {
      var value = ui.value;
      SCMAP.settings.labelScale = value / 100;
      if ( SCMAP.settings.storage ) {
         SCMAP.settings.storage['settings.labelScale'] = SCMAP.settings.labelScale;
      }
      map.scene.traverse( function ( object ) {
         if ( ( object instanceof THREE.Sprite ) && object.userData.systemLabel ) {
            object.userData.systemLabel.scaleSprite();
         }
      });
   };
   // UI width slider / settings handling
   $('#sc-map-interface .sc-map-slider-label-size').slider({
      min: ( Number( $("#sc-map-configuration").data('minLabelScale') ) || 0.4 ) * 100,
      max: ( Number( $("#sc-map-configuration").data('maxLabelScale') ) || 2.0 ) * 100,
      value: SCMAP.settings.labelScale * 100,
      change: updateLabelSize,
      slide: updateLabelSize
   });

   var updateLabelOffset = function( event, ui ) {
      var value = ui.value;
      SCMAP.settings.labelOffset = value / 100;
      if ( SCMAP.settings.storage ) {
         SCMAP.settings.storage['settings.labelOffset'] = SCMAP.settings.labelOffset;
      }
      var matrix = window.renderer.cameraRotationMatrix();
      map.scene.traverse( function ( object ) {
         if ( ( object instanceof THREE.Sprite ) && object.userData.systemLabel ) {
            object.userData.systemLabel.positionSprite( matrix );
         }
      });
   };
   // UI width slider / settings handling
   $('#sc-map-interface .sc-map-slider-label-offset').slider({
      min: ( Number( $("#sc-map-configuration").data('minLabelOffset') ) || -6.5 ) * 100,
      max: ( Number( $("#sc-map-configuration").data('maxLabelOffset') ) ||  7.5 ) * 100,
      value: SCMAP.settings.labelOffset * 100,
      change: updateLabelOffset,
      slide: updateLabelOffset
   });

   var updateSystemScale = function( event, ui ) {
      var value = ui.value;
      SCMAP.settings.systemScale = value / 100;
      if ( SCMAP.settings.storage ) {
         SCMAP.settings.storage['settings.systemScale'] = SCMAP.settings.systemScale;
      }
      var matrix = window.renderer.cameraRotationMatrix();
      var scale;
      map.scene.traverse( function ( object ) {
         if ( object.userData.scale && object.userData.isSystem ) {
            scale = SCMAP.settings.systemScale;
            object.scale.set( scale, scale, scale );
            object.updateMatrix();
         //   object.userData.systemLabel.positionSprite( matrix );
         } else if ( object.userData.scale && object.userData.isGlow ) {
            scale = object.userData.scale * SCMAP.System.GLOW_SCALE * SCMAP.settings.systemScale;
            object.scale.set( scale, scale, scale );
         }
      });
   };
   // UI width slider / settings handling
   $('#sc-map-interface .sc-map-slider-system-size').slider({
      min: ( Number( $("#sc-map-configuration").data('minSystemScale') ) || 0.5 ) * 100,
      max: ( Number( $("#sc-map-configuration").data('maxSystemScale') ) || 2.0 ) * 100,
      value: SCMAP.settings.systemScale * 100,
      change: updateSystemScale,
      slide: updateSystemScale
   });

   $('#sc-map-toggle-stats')
      .prop( 'checked', ( storage && storage['renderer.Stats'] === '1' ) ? true : false )
      .on( 'change', function() {
         if ( this.checked ) {
            $('#stats').show();
         } else {
            $('#stats').hide();
         }
         if ( storage ) {
            storage['renderer.Stats'] = ( this.checked ) ? '1' : '0';
         }
      });

   $('#sc-map-toggle-antialias')
      .on( 'change', function() {
         SCMAP.settings.effect.Antialias = this.checked;
         SCMAP.settings.save( 'effect' );
         window.location.reload( false );
      });

   $('#sc-map-toggle-fxaa')
      .prop( 'disabled', SCMAP.settings.effect.Antialias )
      .on( 'change', function() {
         SCMAP.settings.effect.FXAA = this.checked;
         SCMAP.settings.save( 'effect' );
         if ( renderer.FXAA ) {
            renderer.FXAA.enabled = this.checked;
         }
      });

   $('#sc-map-toggle-bloom')
      .prop( 'disabled', SCMAP.settings.effect.Antialias )
      .on( 'change', function() {
         SCMAP.settings.effect.Bloom = this.checked;
         SCMAP.settings.save( 'effect' );
         if ( renderer.composer ) {
            for ( var i = 0; i < renderer.composer.passes.length; i++ ) {
               if ( renderer.composer.passes[i] instanceof THREE.BloomPass ) {
                  renderer.composer.passes[i].enabled = this.checked;
               }
            }
         }
      });

   $('#sc-map-toggle-glow').on( 'change', function() {
      SCMAP.settings.glow = this.checked;
      map.updateSystems();
      if ( storage ) {
         storage['settings.Glow'] = ( this.checked ) ? '1' : '0';
      }
   });

   $('#sc-map-toggle-labels').on( 'change', function() {
      SCMAP.settings.labels = this.checked;
      $('#sc-map-toggle-label-icons').prop( 'disabled', !SCMAP.settings.labels );
      map.updateSystems();
      if ( storage ) {
         storage['settings.Labels'] = ( this.checked ) ? '1' : '0';
      }
   });

   $('#sc-map-toggle-label-icons')
      .prop( 'disabled', !SCMAP.settings.labels )
      .on( 'change', function() {
         SCMAP.settings.labelIcons = this.checked;
         map.updateSystems();
         if ( storage ) {
            storage['settings.LabelIcons'] = ( this.checked ) ? '1' : '0';
         }
   });

   $('.quick-button.with-checkbox').on( 'click', function ( event ) {
      var $this = $(this);
      $this.find('input[type=checkbox]').click();
   });

   $('#sc-map-interface').on( 'click', 'a[data-toggle-next]', function ( event ) {
      var $this = $(this);
      event.preventDefault();
      var $element = $this.parent().next();
      $element.toggle();
      var title = $this.data('title');
      var storage = null;
      if ( hasSessionStorage() ) {
         storage = window.sessionStorage;
      }
      if ( $element.is(':visible') ) {
         $this.parent().find('> a > i').first().removeClass('fa-caret-right').addClass('fa-caret-down');
         if ( storage ) {
            storage[ title ] = '1';
         }
      } else {
         $this.parent().find('> a > i').first().addClass('fa-caret-right').removeClass('fa-caret-down');
         if ( storage ) {
            delete storage[ title ];
         }
      }

      ui.updateHeight();
   });

   $('#sc-map-interface').on( 'click', 'a[data-toggle-child]', function ( event ) {
      var $this = $(this);
      event.preventDefault();
      var $element = $this.parent().find( $this.data('toggle-child') );
      $element.toggle();
      if ( $element.is(':visible') ) {
         $this.parent().find('> a > i').removeClass('fa-caret-right').addClass('fa-caret-down');
      } else {
         $this.parent().find('> a > i').addClass('fa-caret-right').removeClass('fa-caret-down');
      }

      ui.updateHeight();
   });

   $('#sc-map-interface').on( 'click', "a[data-goto='system']", function( event ) {
      event.preventDefault();
      var $this = $(this);
      var system = SCMAP.System.getById( $this.data('system') );
      system.displayInfo();
      renderer.controls.moveTo( system );
   });

   $('#sc-map-interface').on( 'click', "table.routelist .remove-waypoint", function( event ) {
      event.preventDefault();
      var $this = $(this);
      var system = SCMAP.System.getById( $this.data('system') );
      map.route().removeWaypoint( system );
      map.route().update();
      map.route().storeToSession();
   });

   $('#sc-map-interface').on( 'click', 'button.delete-route', function( event ) {
      map.route().destroy();
      map.route().storeToSession();
   });

   var updateComments = function( event ) {
      event.preventDefault();
      var system = SCMAP.System.getById( $(this).data('system') );
      var text = $(this).val();
      if ( typeof text === 'string' && text.length > 0 ) {
         system.setComments( text );
         $('#sc-map-interface .user-system-comments-md').html( $(markdown.toHTML( text )) );
      } else {
         system.setComments();
         $('#sc-map-interface .user-system-comments-md').empty();
      }
      system.updateSceneObject( scene );
   };

   $('#sc-map-interface').on( 'keyup', '.user-system-comments', updateComments );
   $('#sc-map-interface').on( 'blur', '.user-system-comments', updateComments );
   $('#sc-map-interface').on( 'change', '.user-system-comments', updateComments );

   $('#sc-map-interface').on( 'click', '.remove-system-comments', function( event ) {
      event.preventDefault();
      var system = SCMAP.System.getById( $(this).data('system') );
      system.setComments();
      $('.comment-editing .user-system-comments').empty().val('');
      $('.comment-editing .user-system-comments-md').empty();
      system.updateSceneObject( scene );
   });

   $('#sc-map-interface').on( 'change', '.user-system-bookmarked', function() {
      SCMAP.System.getById( $(this).data('system') )
         .setBookmarkedState( this.checked )
         .updateSceneObject( scene );
      SCMAP.settings.save( 'systems' );
   });

   $('#sc-map-interface').on( 'change', '.user-system-ishangar', function() {
      SCMAP.System.getById( $(this).data('system') )
         .setHangarState( this.checked )
         .updateSceneObject( scene );
      SCMAP.settings.save( 'systems' );
   });

   $('#sc-map-interface').on( 'change', '.user-system-avoid', function() {
      SCMAP.System.getById( $(this).data('system') )
         .setToBeAvoidedState( this.checked )
         .updateSceneObject( scene );
      SCMAP.settings.save( 'systems' );
      map.route().rebuildCurrentRoute();
   });

   /* jScrollPane */
   $('#sc-map-interface').jScrollPane({
      showArrows: false,
      horizontalGutter: 6
   });
};

SCMAP.UI.prototype = {

   constructor: SCMAP.UI,

   toTab: function toTab( index ) {
      var tab = SCMAP.UI.Tab( index );
      $('#sc-map-interface').tabs( 'option', 'active', tab.index );
      this.updateHeight();
   },

   toTabTop: function toTabTop() {
      if ( this.jScrollPane() ) {
         this.jScrollPane().scrollToPercentY( 0 );
      }
   },

   updateHeight: function updateHeight() {
      var _this = this;
      var activeTab = SCMAP.UI.ActiveTab();
      if ( activeTab ) {
         var $images = $( activeTab.id+' img' );
         if ( $images.length ) {
            $( activeTab.id ).imagesLoaded( function() {
               if ( _this.jScrollPane() ) {
                  _this.jScrollPane().reinitialise();
               }
            });
         } else {
            if ( _this.jScrollPane() ) {
               _this.jScrollPane().reinitialise();
            }
         }
      }
   },

   jScrollPane: function jScrollPane() {
      if ( $('#sc-map-interface').data('jsp') ) {
         return $('#sc-map-interface').data('jsp');
      }
   },

   updateSystemsList: function updateSystemsList() {
      var tab = SCMAP.UI.Tab( 'systems' );
      $( tab.id ).empty().append(
         SCMAP.UI.Templates.listings({ systemGroups: SCMAP.UI.buildDynamicLists() })
      );
   }
};

SCMAP.UI.menuBar = []; // Populated by template code

SCMAP.UI.widthClasses = [ 'widthXS', 'widthS', 'widthN', 'widthL', 'widthXL' ];
SCMAP.UI.defaultWidthIndex = 2;
SCMAP.UI.widthClassToIndex = function widthClassToIndex( name ) {
   if ( typeof name === 'string' ) {
      for ( var i = 0; i < SCMAP.UI.widthClasses.length; i += 1 ) {
         if ( name === SCMAP.UI.widthClasses[i] ) {
            return i;
         }
      }
   }
   return SCMAP.UI.defaultWidthIndex;
};

SCMAP.UI.Tabs = [];
SCMAP.UI.Tab = function Tab( name ) {
   for ( var i = 0; i < SCMAP.UI.Tabs.length; i += 1 ) {
      if ( ( typeof name === 'string' ) && ( SCMAP.UI.Tabs[ i ].name === name ) ) {
         return SCMAP.UI.Tabs[ i ];
      } else if ( ( typeof name === 'number' ) && ( SCMAP.UI.Tabs[ i ].id === name ) ) {
         return SCMAP.UI.Tabs[ i ];
      }
   }
   return;
};

SCMAP.UI.ActiveTab = function ActiveTab() {
   var activeTabIndex = $('#sc-map-interface').tabs( "option", "active" );
   for ( var i = 0; i < SCMAP.UI.Tabs.length; i += 1 ) {
      if ( i === activeTabIndex ) {
         return SCMAP.UI.Tabs[ i ];
      }
   }
   return;
};

SCMAP.UI.makeSafeForCSS = function makeSafeForCSS( name ) {
   if ( typeof name !== 'string' ) {
      return;
   }
   return name.replace( /[^a-zA-Z0-9]/g, function(s) {
      var c = s.charCodeAt(0);
      if (c == 32) return '-';
      if (c >= 65 && c <= 90) return '_' + s.toLowerCase();
      return (c.toString(16)).slice(-4);
   });
};

SCMAP.UI.fontAwesomeIsReady = false;
SCMAP.UI.waitForFontAwesome = function waitForFontAwesome( callback ) {
   var retries = 5;

   var checkReady = function() {
      var canvas, context;
      retries -= 1;
      canvas = document.createElement('canvas');
      canvas.width = 20;
      canvas.height = 20;
      context = canvas.getContext('2d');
      context.fillStyle = 'rgba(0,0,0,1.0)';
      context.fillRect( 0, 0, 20, 20 );
      context.font = '16pt FontAwesome';
      context.textAlign = 'center';
      context.fillStyle = 'rgba(255,255,255,1.0)';
      context.fillText( '\uf0c8', 10, 18 );
      var data = context.getImageData( 2, 10, 1, 1 ).data;
      if ( data[0] !== 255 && data[1] !== 255 && data[2] !== 255 ) {
         console.log( "FontAwesome is not yet available, retrying ..." );
         if ( retries > 0 ) {
            setTimeout( checkReady, 200 );
         }
      } else {
         console.log( "FontAwesome is loaded" );
         SCMAP.UI.fontAwesomeIsReady = true;
         if ( typeof callback === 'function' ) {
            callback();
         }
      }
   };

   checkReady();
};

SCMAP.UI.buildDynamicLists = function buildDynamicLists() {
   var hangars = [];
   var bookmarked = [];
   var withComments = [];
   var byFaction = [];
   var everything = [];
   var factionsById = {};
   var data = [];

   for ( var factionId in SCMAP.data.factions ) {
      var faction = SCMAP.data.factions[factionId];
      factionsById[ faction.id ] = {
         faction: faction.name,
         items: []
      };
   }

   var factions = [];

   $( SCMAP.System.List ).each( function ( i, system ) {
      var link = system.createInfoLink().outerHtml(); // TODO replace with template

      if ( system.hasHangar() ) { hangars.push( link ); }
      if ( system.isBookmarked() ) { bookmarked.push( link ); }
      if ( system.hasComments() ) { withComments.push( link ); }

      factionsById[ system.faction.id ].items.push( link );
      everything.push( link );
   });

   if ( hangars.length ) {
      data.push({
         title: "Hangar locations&nbsp;"+SCMAP.Symbol.getTag( SCMAP.Symbols.HANGAR ).addClass('fa-lg').outerHtml(),
         items: hangars
      });
   }

   if ( bookmarked.length ) {
      data.push({
         title: "Bookmarked&nbsp;"+SCMAP.Symbol.getTag( SCMAP.Symbols.BOOKMARK ).addClass('fa-lg').outerHtml(),
         items: bookmarked
      });
   }

   if ( withComments.length ) {
      data.push({
         title: "With your comments&nbsp;"+SCMAP.Symbol.getTag( SCMAP.Symbols.COMMENTS ).addClass('fa-lg').outerHtml(),
         items: withComments
      });
   }

   data.push(
     {
         title: "By faction",
         factions: factionsById
      },
      {
         title: "Everything",
         items: everything
      }
   );

   return data;
};

SCMAP.UI.htmlEscape = function htmlEscape(str) {
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
};

SCMAP.UI.Templates = {
   mapUI:      Handlebars.compile( $('#templateMapUI').html() ),
   systemInfo: Handlebars.compile( $('#templateSystemInfo').html() ),
   listings:   Handlebars.compile( $('#templateSystemsListing').html() ),
   routeList:  Handlebars.compile( $('#templateRouteList').html() )
};

$(function() {
   var sectionLevel = 1;
   var tabCounter = 0;

   Handlebars.registerHelper( 'uiSection', function( title, shouldOpen, options ) {
      var opened = ( shouldOpen ) ? true : false;
      var icon = 'fa-caret-right';
      var hidden = 'style="display: none;"';
      var attrs = [], str;
      var oldLevel = sectionLevel++;
      var storage = null;
      if ( hasSessionStorage() ) {
         storage = window.sessionStorage;
      }

      if ( storage && ( title in storage ) ) {
         opened = ( storage[ title ] == '1' ) ? true : false;
      }

      if ( opened ) {
         icon = 'fa-caret-down';
         hidden = '';
      }

      for ( var prop in options.hash ) {
         attrs.push( prop + '="' + options.hash[prop] + '"' );
      }

      str = '<h'+oldLevel+'><a href="#" data-title="'+SCMAP.UI.htmlEscape(title)+
         '" data-toggle-next="next" '+attrs.join(" ")+'><i class="fa fa-fw fa-lg '+icon+'">'+
         '</i>'+title+'</a></h'+oldLevel+">\n"+'         <div class="ui-section" '+hidden+'>';

      if ( 'fn' in options ) {
         str += options.fn( this );
      }

      str += '</div>';
      sectionLevel -= 1;
      return new Handlebars.SafeString( str );
   });

   Handlebars.registerHelper( 'tabHeader', function( title ) {
      return new Handlebars.SafeString( '<h1 class="padleft">'+title+'</h1>' );
   });

   /* title: shown to user, name: internal name, icon: font awesome icon class */
   Handlebars.registerHelper( 'jQueryUiTab', function( title, name, icon, options ) {
      var hidden = 'style="display: none;"';
      var attrs = [], str = '';
      var $menuItem;
      var id = 'sc-map-ui-tab-'+SCMAP.UI.makeSafeForCSS( name );

      //for ( var prop in options.hash ) {
      //   attrs.push( prop + '="' + options.hash[prop] + '"' );
      //}

      $menuItem = $(
         '<li>' +
            '<a title="'+SCMAP.UI.htmlEscape(title)+'" data-tab="'+SCMAP.UI.htmlEscape(name)+'" href="#'+SCMAP.UI.htmlEscape(id)+'">'+
               '<i class="fa fa-fw fa-2x '+SCMAP.UI.htmlEscape(icon)+'"></i>'+
            '</a>'+
         '</li>'
      );
      SCMAP.UI.menuBar.push( $menuItem );

      str = '<div id="' + id + '" class="sc-map-ui-tab" ' + ((tabCounter !== 0) ? 'style="display: none"' : '') + '>';
      if ( 'fn' in options ) {
         str += options.fn( this );
      }
      str += '</div>';

      SCMAP.UI.Tabs.push({ id: '#'+id, name: name, index: tabCounter++ });

      return new Handlebars.SafeString( str );
   });

   Handlebars.registerHelper( 'bigButton', function( id, faClass, title ) {
      return new Handlebars.SafeString( '<button class="big-button" id="'+id+'">'+
         '<i class="fa '+faClass+' fa-fw fa-lg"></i> '+title+'</button>'+'<br>' );
   });

   Handlebars.registerHelper( 'commoditiesList', function( commodities ) {
      if ( !commodities.length ) {
         return new Handlebars.SafeString( '&mdash;' );
      }
      return new Handlebars.SafeString(
         $.map( commodities, function( elem, i ) {
            return SCMAP.data.goods[ elem ].name;
         }).join( ', ' )
      );
   });

   Handlebars.registerHelper( 'markdown', function( markdownText ) {
      return new Handlebars.SafeString( markdown.toHTML( markdownText ) );
   });

   Handlebars.registerHelper( 'colourGetStyle', function( colour ) {
      return new Handlebars.SafeString( colour.getStyle() );
   });

   Handlebars.registerHelper( 'systemLink', function( system, options ) {
      var noIcons = false, noTarget = false;
      if ( 'noIcons' in options.hash ) {
         noIcons = ( options.hash.noIcons ) ? true : false;
      }
      if ( 'noTarget' in options.hash ) {
         noTarget = ( options.hash.noTarget ) ? true : false;
      }
      if ( !(system instanceof SCMAP.System) ) {
         return '';
      }
      return new Handlebars.SafeString( system.createInfoLink( noIcons, noTarget ).outerHtml() );
   });

   Handlebars.registerHelper( 'routeNavLinks', function( prev, next, options ) {
      var str = '', $elem;

      if ( !prev && !next ) {
         return new Handlebars.SafeString( '' );
      }

      if ( prev instanceof SCMAP.System ) {
         $elem = $( '<a></a>' );
         if ( ( prev.faction instanceof SCMAP.Faction ) && ( prev.faction.color instanceof THREE.Color ) ) {
            $elem.css( 'color', prev.faction.color.getStyle() );
         }
         $elem.addClass( 'system-link' );
         $elem.attr( 'data-goto', 'system' );
         $elem.attr( 'data-system', prev.id );
         $elem.attr( 'href', '#system='+encodeURIComponent( prev.name ) );
         $elem.attr( 'title', 'Previous jump, coming from '+prev.name+' ('+prev.faction.name + ' territory)' );
         $elem.empty().append( '<i class="left fa fa-fw fa-arrow-left"></i>' );
         str += $elem.outerHtml();
      } else {
         str += '<i class="left fa fa-fw"></i>';
      }

      if ( next instanceof SCMAP.System ) {
         $elem = $( '<a></a>' );
         if ( ( next.faction instanceof SCMAP.Faction ) && ( next.faction.color instanceof THREE.Color ) ) {
            $elem.css( 'color', next.faction.color.getStyle() );
         }
         $elem.addClass( 'system-link' );
         $elem.attr( 'data-goto', 'system' );
         $elem.attr( 'data-system', next.id );
         $elem.attr( 'href', '#system='+encodeURIComponent( next.name ) );
         $elem.attr( 'title', 'Next jump, leading to '+next.name+' ('+next.faction.name + ' territory)' );
         $elem.empty().append( '<i class="right fa fa-fw fa-arrow-right"></i>' );
         str += $elem.outerHtml();
      } else {
         str += '<i class="right fa fa-fw"></i>';
      }

      return new Handlebars.SafeString( str );
   });

   Handlebars.registerHelper( 'checkboxButton', function( id, title, options ) {
      var attrs = [];
      for ( var prop in options.hash ) {
         if ( prop === 'icon' ) {
            title = title+' <i class="fa fa-lg fa-fw '+options.hash[prop]+'"></i>';
         } else {
            attrs.push( prop + '="' + SCMAP.UI.htmlEscape(options.hash[prop]) + '"' );
         }
      }
      return new Handlebars.SafeString(
         '<span class="checkmark-button">'+
            '<input type="checkbox" id="'+id+'" '+attrs.join(" ")+'>'+
            '<label for="'+id+'">'+title+'</label>'+
         '</span>'
      );
   });

   Handlebars.registerHelper( "debug", function( optionalValue ) {
      console.log( "Current Context", this );
      if (optionalValue) {
         console.log( "Value", optionalValue );
      }
   });

   Handlebars.registerHelper( 'durationHMM', function( duration ) {
      if ( !duration ) {
         return '';
      }
      return new Handlebars.SafeString( duration.toHMM() );
   });

   Handlebars.registerHelper( 'plusOne', function( number ) {
      return new Handlebars.SafeString( number + 1 );
   });

   Handlebars.registerHelper( 'minusOne', function( number ) {
      return new Handlebars.SafeString( number - 1 );
   });

   Handlebars.registerHelper( 'checked', function( isChecked ) {
      return new Handlebars.SafeString( isChecked ? 'checked' : '' );
   });

   Handlebars.registerHelper( 'checkboxOption', function( id, defaultChecked, title, description, options ) {
      var attrs = [];
      var checked = '';
      if ( defaultChecked ) {
         checked = 'checked';
      }
      for ( var prop in options.hash ) {
         if ( prop === 'icon' ) {
            title = title+' <i class="fa fa-lg fa-fw '+options.hash[prop]+'"></i>';
         } else {
            attrs.push( prop + '="' + SCMAP.UI.htmlEscape(options.hash[prop]) + '"' );
         }
      }
      return new Handlebars.SafeString(
         '<span class="checkmark-option">'+
            '<input class="'+id+'" type="checkbox" id="'+id+'" '+checked+'>'+
            '<label for="'+id+'">'+title+
               '<span class="small label-info">'+description+'</span>'+
            '</label>'+
         '</span>'
      );
   });

   $('script[type="text/x-handlebars-template"][data-partial="1"]').each( function( index, elem ) {
      var $elem = $(elem);
      Handlebars.registerPartial( $elem.attr('id'), $elem.html() );
   });
});

// Courtesy of http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/
(function(){
   /*jshint -W082 */

   var attachEvent = document.attachEvent;
   
   if (!attachEvent) {
      var requestFrame = (function(){
         var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function(fn){ return window.setTimeout(fn, 20); };
         return function(fn){ return raf(fn); };
      })();
      
      var cancelFrame = (function(){
      var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;
      return function(id){ return cancel(id); };
      })();

      function resetTriggers(element){
         var triggers = element.__resizeTriggers__,
            expand = triggers.firstElementChild,
            contract = triggers.lastElementChild,
            expandChild = expand.firstElementChild;
         contract.scrollLeft = contract.scrollWidth;
         contract.scrollTop = contract.scrollHeight;
         expandChild.style.width = expand.offsetWidth + 1 + 'px';
         expandChild.style.height = expand.offsetHeight + 1 + 'px';
         expand.scrollLeft = expand.scrollWidth;
         expand.scrollTop = expand.scrollHeight;
      }

      function checkTriggers(element){
         return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;
      }
      
      function scrollListener(e){
         var element = this;
         resetTriggers(this);
         if (this.__resizeRAF__) cancelFrame(this.__resizeRAF__);
         this.__resizeRAF__ = requestFrame(function(){
            if (checkTriggers(element)) {
               element.__resizeLast__.width = element.offsetWidth;
               element.__resizeLast__.height = element.offsetHeight;
               element.__resizeListeners__.forEach(function(fn){
                  fn.call(element, e);
               });
            }
         });
      }
   }
   
   window.addResizeListener = function(element, fn){
      if (attachEvent) {
         element.attachEvent('onresize', fn);
      } else {
         if (!element.__resizeTriggers__) {
            if (getComputedStyle(element).position == 'static') element.style.position = 'relative';
            element.__resizeLast__ = {};
            element.__resizeListeners__ = [];
            (element.__resizeTriggers__ = document.createElement('div')).className = 'resize-triggers';
            element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div>' +
               '<div class="contract-trigger"></div>';
            element.appendChild(element.__resizeTriggers__);
            resetTriggers(element);
            element.addEventListener('scroll', scrollListener, true);
         }
         element.__resizeListeners__.push(fn);
      }
   };
   
   window.removeResizeListener = function(element, fn){
      if (attachEvent) {
         element.detachEvent('onresize', fn);
      } else {
         element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
         if (!element.__resizeListeners__.length) {
            element.removeEventListener('scroll', scrollListener);
            element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
         }
      }
   };
})();

// End of file

/**
  * @author Lianna Eeftinck / https://github.com/Leeft
  */

SCMAP.Renderer = function ( map ) {
   this.map = map;

   this.composer = null;
   this.FXAA = null;
   this.camera = null;

   this.textureManager = new SCMAP.TextureManager();
   
   this.width = window.innerWidth;
   this.height = window.innerHeight;

   this.resize  = this._resize.bind( this );
   this.animate = this._animate.bind( this );
   this.render  = this._render.bind( this );

   this.dpr = 1;
   if ( window.devicePixelRatio !== undefined ) {
      this.dpr = window.devicePixelRatio;
   }

   var container = $('#sc-map-webgl-container')[0];

   this.camera = new THREE.PerspectiveCamera( 45, this.width / this.height, 10, 1600 );
   this.camera.position.copy( SCMAP.settings.camera.camera );
   this.camera.setViewOffset( this.width, this.height, -( $('#sc-map-interface .sc-map-ui-padding').width() / 2 ), 0, this.width, this.height );

   this.controls = new SCMAP.OrbitControls( this, container );
   this.controls.target.copy( SCMAP.settings.camera.target );
   this.controls.rotateSpeed = $('#sc-map-configuration').data('rotateSpeed');
   this.controls.zoomSpeed = $('#sc-map-configuration').data('zoomSpeed');
   this.controls.panSpeed = $('#sc-map-configuration').data('panSpeed');
   this.controls.noRotate = SCMAP.settings.control.rotationLocked;

   this.threeRenderer = new THREE.WebGLRenderer( { antialias: true } );
   if ( ! SCMAP.settings.effect.Antialias ) {
      this.threeRenderer.autoClear = false;
   }
   this.threeRenderer.setClearColor( 0x000000, 1 );
   this.threeRenderer.setSize( this.width, this.height );

   container.appendChild( this.threeRenderer.domElement );

   var renderer = this;

   // Stats

   this.stats = new Stats();
   this.stats.domElement.style.position = 'absolute';
   this.stats.domElement.style.top = '0px';
   this.stats.domElement.style.right = '0px';
   this.stats.domElement.style.display = 'none';
   this.stats.domElement.style.zIndex = '100';
   container.appendChild( this.stats.domElement );
   if ( SCMAP.settings.renderer.Stats ) {
      $('#stats').show();
   }

   if ( hasLocalStorage() ) {
      storage = window.localStorage;
   }

   // Event handlers

   window.addEventListener( 'resize', this.resize, false );
   document.addEventListener( 'change', this.render, false );

   if ( ! SCMAP.settings.effect.Antialias )
   {
      var renderModel = new THREE.RenderPass( this.map.scene, this.camera );

      this.FXAA = new THREE.ShaderPass( THREE.FXAAShader );
      this.FXAA.uniforms.resolution.value.set( 1 / (this.width * this.dpr), 1 / (this.height * this.dpr) );
      this.FXAA.enabled = SCMAP.settings.effect.FXAA;

      var effectBloom = new THREE.BloomPass( 0.6 );
      effectBloom.enabled = SCMAP.settings.effect.Bloom;

      var effectCopy = new THREE.ShaderPass( THREE.CopyShader );
      effectCopy.renderToScreen = true;

      this.composer = new THREE.EffectComposer( this.threeRenderer );
      this.composer.setSize( this.width * this.dpr, this.height * this.dpr );
      this.composer.addPass( renderModel );
      this.composer.addPass( this.FXAA );
      this.composer.addPass( effectBloom );
      this.composer.addPass( effectCopy );
   }

   this.animate();
};

SCMAP.Renderer.prototype = {
   constructor: SCMAP.Renderer,

   cameraRotationMatrix: function cameraRotationMatrix() {
      var euler = new THREE.Euler( this.camera.userData.phi + Math.PI / 2, this.camera.userData.theta, 0, 'YXZ' );
      return new THREE.Matrix4().makeRotationFromEuler( euler );
   },

   _resize: function _resize() {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      this.camera.aspect = this.width / this.height;
      this.camera.setViewOffset( this.width, this.height, -( $('#sc-map-interface .sc-map-ui-padding').width() / 2 ), 0, this.width, this.height );
      this.camera.updateProjectionMatrix();

      if ( this.FXAA ) {
         this.FXAA.uniforms.resolution.value.set( 1 / (this.width * this.dpr), 1 / (this.height * this.dpr) );
      }

      this.threeRenderer.setSize( this.width, this.height );
      if ( this.composer ) {
         this.composer.reset();
      }

      window.ui.updateHeight();
   },

   _animate: function _animate() {
      requestAnimationFrame( this.animate );
      TWEEN.update();
      this.controls.update();
      //if ( editor !== undefined ) {
      //   editor.update();
      //}
      this.map.animate();
      this.stats.update();
      this.render();
   },

   _render: function _render() {
      if ( this.composer ) {
         this.threeRenderer.clear();
         this.composer.render();
      } else {
         this.threeRenderer.render( this.map.scene, this.camera );
      }
   }
};

function brillitos() {
    var particleCount = 1800,
        particles = new THREE.Geometry(),

        pMaterial = new THREE.PointCloudMaterial({
            color: 0xFFFFFF,
            size: 20,
            map: THREE.ImageUtils.loadTexture(
                "images/particle.png"
            ),
            blending: THREE.AdditiveBlending,
            transparent: true
        });


    // now create the individual particles
    for (var p = 0; p < particleCount; p++) {

        // create a particle with random
        // position values, -250 -> 250
        var pX = Math.random() * 500 - 250,
            pY = Math.random() * 500 - 250,
            pZ = Math.random() * 500 - 250,
            particle = new THREE.Vector3(pX, pY, pZ);

        // add it to the geometry
        particles.vertices.push(particle);
    }

    // create the particle system
    var particleSystem = new THREE.PointCloud(
        particles,
        pMaterial);

    particleSystem.sortParticles = true;

    // add it to the scene
    scene.add(particleSystem);
}

function generateGalaxy() {
    //Generating the plane
    var planeGeometry = new THREE.PlaneGeometry(1500, 1500);
    var planeMaterial = new THREE.MeshBasicMaterial({
        side: THREE.DoubleSide,
        map: THREE.ImageUtils.loadTexture("images/Milky_Way_2005.jpg")
    });
    var planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
    planeMesh.rotation.x = (3 * Math.PI) / 2;
    planeMesh.position.x = 100;
    planeMesh.position.y = -0.5;
    scene.add(planeMesh);
}

function buildGalaxy() {

    /*
     * Generate a procedural Galaxy (https://github.com/robertkleffner/html5-galaxy)
     * Code updated for THREE r68
     */
    var outerRing = new THREE.Geometry();
    var outerClouds = new THREE.Geometry();
    var innerRing = new THREE.Geometry();
    var innerClouds = new THREE.Geometry();
    var outerStars = new THREE.Geometry();
    var starMaterial = new THREE.PointCloudMaterial({
        size: 20,
        map: THREE.ImageUtils.loadTexture(
            "images/galactic_stars.png"
        ),
        blending: THREE.AdditiveBlending,
        vertexColors: true,
        transparent: true,
        depthTest: false
    });
    starMaterial.color.setHSL(1.0, 0.0, 1.0);
    var cloudMaterial = new THREE.PointCloudMaterial({
        size: 300,
        map: THREE.ImageUtils.loadTexture(
            "images/galactic_clouds.png"
        ),
        blending: THREE.AdditiveBlending,
        vertexColors: true,
        transparent: true,
        depthTest: false
    });
    // Creating individual particles
    var color = [];
    for (var p = 0; p < 1800; p++) {
        var angle = Math.random() * Math.PI * 2;
        var radius = Math.random() * 200 + 400;
        var pX = Math.cos(angle) * radius,
            pY = Math.random() * 70 - 35,
            pZ = Math.sin(angle) * radius,
            skparticle = new THREE.Vector3(pX, pY, pZ);
        outerRing.vertices.push(skparticle);

        var h = Math.random() * (291 - 185) + 185,
            s = Math.random() * (66 - 34) + 34,
            v = Math.random() * (100 - 72) + 72;
        color[p] = new THREE.Color(0xffffff);
        color[p].setHSL(h / 360, s / 100, v / 100);
    }
    outerRing.colors = color;

    color = [];
    for (var sk1 = 0; sk1 < 5000; sk1++) {
        var angle1 = Math.random() * Math.PI * 2;
        var radius1 = Math.random() * 350 + 1;
        var pX1 = Math.cos(angle1) * radius1,
            pY1 = Math.random() * 200 * (1 / radius1) * (Math.random() > 0.5 ? 1 : -1),
            pZ1 = Math.sin(angle1) * radius1,
            skparticle1 = new THREE.Vector3(pX1, pY1, pZ1);
        innerRing.vertices.push(skparticle1);

        var h1 = Math.random() * (291 - 185) + 185,
            s1 = Math.random() * (66 - 34) + 34,
            v1 = Math.random() * (100 - 72) + 72;
        color[sk1] = new THREE.Color(0xffffff);
        color[sk1].setHSL(h1 / 360, s1 / 100, v1 / 100);
    }
    innerRing.colors = color;

    color = [];
    for (var sk2 = 0; sk2 < 200; sk2++) {
        var angle2 = Math.random() * Math.PI * 2;
        var radius2 = Math.random() * 350 + 1;
        var pX2 = Math.cos(angle2) * radius2,
            pY2 = Math.random() * 200 * (1 / radius2) * (Math.random() > 0.5 ? 1 : -1),
            pZ2 = Math.sin(angle2) * radius2,
            skparticle2 = new THREE.Vector3(pX2, pY2, pZ2);
        innerClouds.vertices.push(skparticle2);

        var h2 = Math.random() * (291 - 185) + 185,
            s2 = Math.random() * (66 - 34) + 34,
            v2 = Math.random() * (100 - 72) + 72;
        color[sk2] = new THREE.Color(0xffffff);
        color[sk2].setHSL(h2 / 360, s2 / 100, v2 / 100);
    }
    innerClouds.colors = color;

    color = [];
    for (var sk3 = 0; sk3 < 200; sk3++) {
        var angle3 = Math.random() * Math.PI * 2;
        var radius3 = Math.random() * 200 + 400;
        var pX3 = Math.cos(angle3) * radius3,
            pY3 = Math.random() * 70 - 35,
            pZ3 = Math.sin(angle3) * radius3,
            skparticle3 = new THREE.Vector3(pX3, pY3, pZ3);
        outerClouds.vertices.push(skparticle3);

        var h3 = Math.random() * (291 - 185) + 185,
            s3 = Math.random() * (66 - 34) + 34,
            v3 = Math.random() * (100 - 72) + 72;
        color[sk3] = new THREE.Color(0xffffff);
        color[sk3].setHSL(h3 / 360, s3 / 100, v3 / 100);
    }
    outerClouds.colors = color;

    color = [];
    for (var sk4 = 0; sk4 < 1000; sk4++) {

        var radius5 = Math.random() * 1000 + 1000;
        var z = Math.random() * (2 * radius5) - radius5;
        var phi = Math.random() * Math.PI * 2;
        var theta = Math.asin(z / radius5);

        var pX5 = Math.cos(theta) * Math.cos(phi) * radius5,
            pY5 = Math.cos(theta) * Math.sin(phi) * radius5,
            pZ5 = z,
            skparticle4 = new THREE.Vector3(pX5, pY5, pZ5);
        outerStars.vertices.push(skparticle4);

        color[sk4] = new THREE.Color(0xffffff);
    }
    outerStars.colors = color;

    var outerSystem = new THREE.PointCloud(outerRing, starMaterial);
    var innerSystem = new THREE.PointCloud(innerRing, starMaterial);
    var cloudSystem = new THREE.PointCloud(innerClouds, cloudMaterial);
    var cloudSystem2 = new THREE.PointCloud(outerClouds, cloudMaterial);
    var starSystem = new THREE.PointCloud(outerStars, starMaterial);

    scene.add(outerSystem);
    scene.add(innerSystem);
    scene.add(cloudSystem);
    scene.add(cloudSystem2);
    scene.add(starSystem);
}

function smokeTest () {
   var smokeParticles = new THREE.Geometry();
   for (i = 0; i < 25; i++) {
       var particle = new THREE.Vector3( Math.random() * 8, Math.random() * 10 + 5, Math.random() * 8 );
       smokeParticles.vertices.push( particle );
   }
   var smokeTexture = THREE.ImageUtils.loadTexture('images/smoke.png');
   var smokeMaterial = new THREE.ParticleBasicMaterial({
      map: smokeTexture,
      transparent: true,
      blending: THREE.AdditiveBlending,
      size: 25,
      color: 0x111111
   });
   
   var smoke = new THREE.ParticleSystem(smokeParticles, smokeMaterial);
   smoke.sortParticles = true;
   smoke.position.x = 10;
   
   scene.add(smoke);
}

function buildCross () {
   var material = new THREE.MeshBasicMaterial( { wireframe: true, color: 0xFF0000, linewidth: 1 } );
   var group = new THREE.Object3D();
   var geo = new THREE.Geometry();
   geo.vertices.push( new THREE.Vector3( -50, 1, 0 ) );
   geo.vertices.push( new THREE.Vector3( 50, 1, 0 ) );
   var cross = new THREE.Line( geo, material );
   group.add( cross );
   geo = new THREE.Geometry();
   var material2 = new THREE.MeshBasicMaterial( { wireframe: true, color: 0xF0F000, linewidth: 1 } );
   geo.vertices.push( new THREE.Vector3( 0, 1, -50 ) );
   geo.vertices.push( new THREE.Vector3( 0, 1, 50 ) );
   cross = new THREE.Line( geo, material2 );
   group.add( cross );
   var material3 = new THREE.MeshBasicMaterial( { wireframe: true, color: 0x0000F0, linewidth: 1 } );
   geo = new THREE.Geometry();
   geo.vertices.push( new THREE.Vector3( 0, -50, 0 ) );
   geo.vertices.push( new THREE.Vector3( 0, 50, 0 ) );
   cross = new THREE.Line( geo, material3 );
   group.add( cross );
   return group;
}

//

// End of file

/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 * @author Leeft / https://github.com/Leeft
 */
/*global THREE, console */

// This set of controls performs orbiting, dollying (zooming), and panning. It maintains
// the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
// supported.
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finter swipe
//
// This is a drop-in replacement for (most) TrackballControls used in examples.
// That is, include this js file and wherever you see:
//       controls = new THREE.TrackballControls( camera );
//      controls.target.z = 150;
// Simple substitute "OrbitControls" and the control should work as-is.

// Heavily modified version of OrbitControls.js (by Leeft) with a finite
// state machine for dealing with the user's input (I needed more than
// just basic control).

SCMAP.OrbitControls = function ( renderer, domElement ) {

   this.object     = renderer.camera;
   this.domElement = ( domElement !== undefined ) ? domElement : document;

   this.map        = renderer.map;

   // API

   // Set to false to disable this control
   this.enabled = true;

   // "target" sets the location of focus, where the control orbits around
   // and where it pans with respect to.
   this.target = new THREE.Vector3();

   // center is old, deprecated; use "target" instead
   this.center = this.target;

   // This option actually enables dollying in and out; left as "zoom" for
   // backwards compatibility
   this.noZoom = false;
   this.zoomSpeed = 1.0;

   // Limits to how far you can dolly in and out
   this.minDistance = 20;
   this.maxDistance = 800;

   // Set to true to disable this control
   this.noRotate = false;
   this.rotateSpeed = 1.0;

   // Set to true to disable this control
   this.noPan = false;
   this.keyPanSpeed = 40; // pixels moved per arrow key push
   this.mapMode = true; // map mode pans on x,z

   // How far you can orbit vertically, upper and lower limits.
   // Range is 0 to Math.PI radians.
   this.minPolarAngle = 0; // radians
   this.maxPolarAngle = THREE.Math.degToRad( 85 ); // radians

   // Set to true to disable use of the keys
   this.noKeys = false;

   // The keys
   this.keys = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      BOTTOM: 40,
      ESCAPE: 27,
      R: 82,
      C: 67,
      T: 84,
      2: 50,
      3: 51,
      L: 76,
      SPACE: 32,
      TAB: 9
   };

   ////////////
   // internals

   var scope = this;

   var EPS = 0.000001;

   var rotateStart = new THREE.Vector2();
   var rotateEnd = new THREE.Vector2();
   var rotateDelta = new THREE.Vector2();

   var panStart = new THREE.Vector2();
   var panEnd = new THREE.Vector2();
   var panDelta = new THREE.Vector2();
   var panOffset = new THREE.Vector3();

   var dollyStart = new THREE.Vector2();
   var dollyEnd = new THREE.Vector2();
   var dollyDelta = new THREE.Vector2();

   var mousePrevious = new THREE.Vector2(); // FIXME

   var phiDelta = 0;
   var thetaDelta = 0;
   var scale = 1;
   var pan = new THREE.Vector3();

   var lastPosition = new THREE.Vector3();
   var lastQuaternion = new THREE.Quaternion();

   this.debug = false; // TODO unset

   var startObject; // drag start
   var endObject;   // drag end

   var mouseOver; // where the mouse is at // TODO fixme

   // for reset

   this.target0 = this.target.clone();
   this.position0 = this.object.position.clone();

   // so camera.up is the orbit axis

   var quat = new THREE.Quaternion().setFromUnitVectors( this.object.up, new THREE.Vector3( 0, 1, 0 ) );
   var quatInverse = quat.clone().inverse();

   // events

   var changeEvent = { type: 'change' };
   var startEvent = { type: 'start' };
   var endEvent = { type: 'end' };

   var state = StateMachine.create({
      initial: { state: 'loading', event: 'init', defer: true },

      events: [
         { name: 'startup', from: 'loading', to: 'idle' },

         // Start events
         { name: 'starttouch',  from: 'idle',   to: 'touch'  },
            { name: 'touchtodrag',   from: 'touch',  to: 'drag'   }, // LMB; Dragging with initial target
            { name: 'touchtorotate', from: 'touch',  to: 'rotate' }, // LMB; Dragging without initial target
            { name: 'touchtodolly',  from: 'touch',  to: 'dolly'  }, // MMB; Dollying (zooming)
            { name: 'touchtopan',    from: 'touch',  to: 'pan'    }, // RMB; Panning

         { name: 'startdolly',  from: 'idle',   to: 'dolly'  },
         { name: 'startpan',    from: 'idle',   to: 'pan' },

         // Stop events
         { name: 'idle', from: ['*'], to: 'idle' }

      ],

      callbacks: {

         onenterstate: function( stateEvent, from, to ) {
            scope.showState( to );
         },

         onentertouch: function( stateEvent, from, to, event ) {
            if ( scope.enabled === false ) { return; }
            event.preventDefault();
            if ( scope.debug ) {
               console.log( stateEvent, ": entered state", to, "from", from );
            }

            var intersect;

            if ( event.button === 0 ) { // left mouse

               // If the click starts on an object, we're dragging from
               // that object (possibly to another object) so we take
               // note of that object and switch to the drag state
               intersect = scope.getIntersect( event );
               if ( intersect && intersect.object.parent.userData.system ) {
                  startObject = intersect.object.parent.userData.system;
                  if ( scope.debug ) {
                     console.log( 'Click at "' + intersect.object.parent.userData.system.name + '"' );
                  }
                  window.map.setSelectionTo( startObject );
                  startObject.displayInfo( 'doNotSwitch' );
                  this.touchtodrag( event );
               }
               else if ( ! scope.noRotate )
               {
                  // If the click starts in empty space, we're just going to
                  // the mode for rotating the camera around the scene as
                  // that is the easiest thing to do
                  if ( scope.noRotate === true ) { return; }
                  rotateStart.set( event.clientX, event.clientY );
                  this.touchtorotate( event );
               }

            } else if ( event.button === 1 ) { // middle mouse

               if ( scope.noZoom === true ) { return; }
               dollyStart.set( event.clientX, event.clientY );
               this.touchtodolly( event );

            }

            if ( event.button === 2 || (scope.noRotate && ! intersect) ) { // right mouse

               if ( scope.noPan === true ) { return; }
               panStart.set( event.clientX, event.clientY );
               this.touchtopan( event );

            }
         },

         onenterdrag: function( stateEvent, from, to, event ) {
            if ( scope.enabled === false ) { return; }
            if ( scope.debug ) {
               console.log( stateEvent, ": entered state", to, "from", from );
            }
         },

         onenteridle: function( stateEvent, from, to, event ) {
            if ( scope.debug ) {
               console.log( stateEvent, ": idling after", from );
            }

            if ( from === 'drag' ) {

               var intersect = scope.getIntersect( event );
               if ( intersect && intersect.object.parent.userData.system )
               {
                  endObject = intersect.object.parent.userData.system;
                  if ( scope.debug ) {
                     console.log( 'Ended dragging at "' + endObject.toString() + '"' );
                  }

                  if ( endObject === startObject ) {
                     endObject.displayInfo();
                  }
                  else
                  {
                     if ( window.map.selected() === endObject ) {
                     }
                     var route = window.map.route();
                     if ( route.isSet() && startObject !== endObject ) {
                        route.update( endObject );
                        route.storeToSession();
                        ui.toTab( 'route' );
                     }
                  }
               }
            }

            startObject = undefined;
            endObject = undefined;

            if ( scope.debug ) {
               console.log( 'idling ...' );
            }
         },

      },

      error: function( eventName, from, to, args, errorCode, errorMessage ) {
         if ( scope.debug ) {
            console.log( 'event ' + eventName + ' was naughty : ' + errorMessage );
         }
      }
   });

   var targetTween;
   var rotationTween;
   var rotationLeft;
   var rotationUp;
   var rotationRadius;

   var isMoving = false;

   this.stateMachine = function () {
      return state;
   };

   this.showState = function ( to ) {
      if ( window.jQuery && window.jQuery('#debug-state') ) {
         window.jQuery('#debug-state').text( 'State: ' + to );
      }
   };

   this.rotateLeft = function ( angle ) {
      if ( angle === undefined ) {
         angle = getAutoRotationAngle();
      }
      thetaDelta -= angle;
   };

   this.rotateUp = function ( angle ) {
      if ( angle === undefined ) {
         angle = getAutoRotationAngle();
      }
      phiDelta -= angle;
   };

   // pass in distance in world space to move left
   this.panLeft = function ( distance ) {

      var te = this.object.matrix.elements;

      // get X column of matrix
      panOffset.set( te[0], te[1], te[2] );
      panOffset.multiplyScalar( - distance );

      pan.add( panOffset );
   };

   // pass in distance in world space to move up
   this.panUp = function ( distance ) {

      if ( this.mapMode ) {
         return this.panBack( distance );
      }
      var panOffset = new THREE.Vector3();
      var te = this.object.matrix.elements;
      // get Y column of matrix
      panOffset.set( te[4], te[5], te[6] );
      panOffset.multiplyScalar(distance);

      pan.add( panOffset );
   };

   // pass in distance in world space to move forward
   this.panBack = function ( distance ) {

      var sameLevelTarget = this.target.clone().setY( this.object.position.y );
      var vectorBack = this.object.position.clone().sub( sameLevelTarget ).negate().setLength( distance );

      pan.add( vectorBack );
   };

   // assumes mapMode for now
   this.moveTo = function ( destination ) {

      var _this = this;
      var traverse = this.target.clone();
      var destinationVector;

      // makes sure the destination is at the same xz plane
      if ( destination instanceof SCMAP.System ) {
         destinationVector = destination.position.clone().setY( this.target.y );
      } else if ( destination instanceof THREE.Vector3 ) {
         destinationVector = destination.clone().setY( this.target.y );
      } else {
         return;
      }

      if ( destination instanceof SCMAP.System ) {
         window.map.setSelectionTo( destination );
      }

      if ( targetTween ) {
         targetTween.stop();
      }

      targetTween = new TWEEN.Tween( traverse )
         .to( { x: destinationVector.x, y: destinationVector.y, z: destinationVector.z }, 750 )
         .easing( TWEEN.Easing.Cubic.InOut )
         .onUpdate( function () {
            var vec = new THREE.Vector3( this.x, this.y, this.z );
            _this.goTo( vec );
            isMoving = true;
         } );

      targetTween.onComplete( function() {
         targetTween = undefined;
      });

      targetTween.start();
   };

   this.rememberPosition = function rememberPosition() {
      SCMAP.settings.camera.camera = this.object.position;
      SCMAP.settings.camera.target = this.target;
      SCMAP.settings.save( 'camera' );
   };

   // assumes mapMode for now
   this.rotateTo = function ( left, up, radius ) {

      var _this = this;
      var offset = this.objectVectorToTarget();
      // angle from z-axis around y-axis
      var theta = Math.atan2( offset.x, offset.z );
      // angle from y-axis
      var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );
      var rotate = {
         left: theta,
         up: phi,
         radius: offset.length()
      };

      rotateLeft = rotate.left;
      rotateUp   = rotate.up;

      if ( rotationTween ) {
         rotationTween.stop();
      }

      rotationTween = new TWEEN.Tween( rotate )
         .to( { left: left, up: up, radius: radius }, 1000 )
         .easing( TWEEN.Easing.Cubic.InOut )
         .onUpdate( function () {
            rotationLeft   = this.left;
            rotationUp     = this.up;
            rotationRadius = this.radius;
            isMoving = true;
            scope.dispatchEvent( changeEvent );
         });

      rotationTween.onComplete( function() {
         rotationTween  = undefined;
         rotationLeft   = undefined;
         rotationUp     = undefined;
         rotationRadius = undefined;
         scope.dispatchEvent( endEvent );
      });

      scope.dispatchEvent( startEvent );
      rotationTween.start();
   };

   this.cameraTo = function ( target, theta, phi, radius ) {
      this.rotateTo( theta, phi, radius );
      this.moveTo( target );
   };


   // assumes mapMode for now
   this.goTo = function ( vector ) {

      // make sure the given vector is at the same xz plane
      vector = vector.clone().setY( this.target.y );
      vector.sub( this.target );
      pan.add( vector );
   };

   // main entry point; pass in Vector2 of change desired in pixel space,
   // right and down are positive
   this.pan = function ( deltaX, deltaY ) {

      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

      if ( scope.object.fov !== undefined ) {

         // perspective
         var position = scope.object.position;
         var offset = position.clone().sub( scope.target );
         var targetDistance = offset.length();

         // half of the fov is center to top of screen
         targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

         // we actually don't use screenWidth, since perspective camera is fixed to screen height
         scope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );
         scope.panUp( 2 * deltaY * targetDistance / element.clientHeight );

      } else if ( scope.object.top !== undefined ) {

         // orthographic
         scope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );
         scope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );

      } else {

         // camera neither orthographic or perspective - warn user
         console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );

      }

   };

   this.dollyIn = function ( dollyScale ) {

      if ( dollyScale === undefined ) {
         dollyScale = getZoomScale();
      }

      scale /= dollyScale;
      isMoving = true;

   };

   this.dollyOut = function ( dollyScale ) {

      if ( dollyScale === undefined ) {
         dollyScale = getZoomScale();
      }

      scale *= dollyScale;
      isMoving = true;

   };

   // TODO: Move to map
   this.getIntersect = function ( event ) {
      if ( !window.map.interactables() ) { return; }
      var vector, projector, raycaster, intersects;
      vector = new THREE.Vector3( (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5 );
      projector = new THREE.Projector();
      projector.unprojectVector( vector, scope.object );
      raycaster = new THREE.Raycaster( scope.object.position, vector.sub( scope.object.position ).normalize() );
      intersects = raycaster.intersectObjects( window.map.interactables() );
      return intersects[0];
   };

   this.objectVectorToTarget = function () {
      return this.object.position.clone().sub( this.target );
   };

   this.currentState = function currentState() {
      return state.current;
   };

   this.cameraIsMoving = function cameraIsMoving() {
      return(
         (state.current === 'pan') ||
         (state.current === 'dolly') ||
         (state.current === 'rotate') ||
         (state.current === 'loading') ||
         !dollyStart.equals( dollyEnd ) ||
         isMoving
      );
   };

   this.throttledEventListener = (function() {

      var callbacks = {}, running = false;

      // fired on events
      function throttled() {

         if ( !running ) {
            running = true;

            if ( window.requestAnimationFrame ) {
               window.requestAnimationFrame( runCallbacks );
            } else {
               setTimeout( runCallbacks, 66 );
            }
         }

      }

      // run the actual callbacks
      function runCallbacks() {
         /*jshint -W083 */
         for ( var type in callbacks ) {
            if ( callbacks.hasOwnProperty( type ) ) {
               callbacks[ type ].forEach( function( callback ) {
                  callback();
               });
            }
         }
         running = false;
      }

      // adds callback to loop
      function addCallback( type, callback) {
         if ( type && callback ) {
            if ( ! ( type in callbacks ) ) {
               callbacks[ type ] = [];
            }
            callbacks[ type ].push( callback );
         }
      }

      return {
         // initalize resize event listener
         init: function( type, callback ) {
            window.renderer.controls.addEventListener( type, throttled );
            addCallback( type, callback );
         },

         // public method to add additional callback
         add: function( type, callback ) {
            addCallback( type, callback );
         }
      };
   }());

   this.update = function update() {

      if ( (state.current === 'idle') && (pan.length() === 0.0) && !isMoving ) {
         return;
      }

      isMoving = true;

      var offset = this.objectVectorToTarget();

      // move target to panned location
      this.target.add( pan );

      // angle from z-axis around y-axis
      var theta = Math.atan2( offset.x, offset.z );

      // angle from y-axis
      var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );

      theta += thetaDelta;
      phi += phiDelta;

      if ( rotationLeft !== undefined ) {
         theta = rotationLeft;
      }
      if ( rotationUp !== undefined ) {
         phi = rotationUp;
      }

      // restrict phi to be between desired limits
      phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );

      // restrict phi to be between EPS and PI-EPS
      phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );

      this.object.userData.phi = phi;
      this.object.userData.theta = theta;

      var radius = offset.length() * scale;
      if ( rotationRadius !== undefined ) {
         radius = rotationRadius;
      }

      $('#debug-angle').html(
         'Camera heading: '+THREE.Math.radToDeg( theta ).toFixed(1)+'&deg; ('+theta.toFixed(2)+')<br>'+
         'Camera tilt: '+THREE.Math.radToDeg( phi ).toFixed(1)+'&deg; ('+phi.toFixed(2)+')<br>'+
         'Camera distance: '+radius.toFixed(1)
      );

      // restrict radius to be between desired limits
      radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );

      offset.x = radius * Math.sin( phi ) * Math.sin( theta );
      offset.y = radius * Math.cos( phi );
      offset.z = radius * Math.sin( phi ) * Math.cos( theta );

      this.object.position.copy( this.target ).add( offset );

      this.object.lookAt( this.target );

      thetaDelta = 0;
      phiDelta = 0;
      scale = 1;
      pan.set( 0, 0, 0 );

      // update condition is:
      // min(camera displacement, camera rotation in radians)^2 > EPS
      // using small-angle approximation cos(x/2) = 1 - x^2 / 8

      if ( lastPosition.distanceToSquared( this.object.position ) > EPS ||
          8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS ) {

         this.dispatchEvent( changeEvent );

         lastPosition.copy( this.object.position );
         lastQuaternion.copy( this.object.quaternion );

      }

      isMoving = false;

   };

   function getAutoRotationAngle() {

      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

   }

   function getZoomScale() {

      return Math.pow( 0.95, scope.zoomSpeed );

   }

   function onMouseDown( event ) {

      if ( scope.enabled === false ) { return; }
      event.preventDefault();

      state.starttouch( event );

      document.addEventListener( 'mousemove', onMouseMove, false );
      document.addEventListener( 'mouseup', onMouseUp, false );
      scope.dispatchEvent( startEvent );
   }

   function onMouseMove( event ) {

      if ( scope.enabled === false ) return;

      event.preventDefault();

      var intersect;
      var route;
      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

      // Mouse move handling: highlighting systems, dragging waypoints on route

      if ( ! scope.cameraIsMoving() )
      {
         if ( event.clientX !== mousePrevious.x && event.clientY !== mousePrevious.y ) {
            intersect = scope.getIntersect( event );
            if ( intersect && intersect.object.parent.userData.system && intersect.object.parent.userData.system !== mouseOver ) {
               mouseOver = intersect.object.parent.userData.system;
               window.map._mouseOverObject.position.copy( mouseOver.sceneObject.position );
               window.map._mouseOverObject.visible = true;
            } else {
               if ( !intersect || !intersect.object.parent.userData.system ) {
                  if ( mouseOver !== undefined ) {
                     window.map._mouseOverObject.position.set( 0, 0, 0 );
                     window.map._mouseOverObject.visible = false;
                  }
                  mouseOver = undefined;
               }
            }
         }
      }

      mousePrevious.set( event.clientX, event.clientY );


      if ( state.current === 'touch' ) {

         if ( event.button === 0 ) { // left mouse
            state.touchtorotate( event );
         } else if ( event.button === 1 ) { // middle mouse
            state.touchtodolly( event );
         } else if ( event.button === 2 ) { // right mouse
            state.touchtopan( event );
         }

      } else if ( state.current === 'drag' ) {

         if ( startObject ) {

            if ( intersect && intersect.object.parent.userData.system && intersect.object.parent.userData.system !== startObject ) {

               if ( !endObject || endObject !== intersect.object.parent.userData.system ) {

                  endObject = intersect.object.parent.userData.system;
                  route = window.map.route();

                  if ( !route.isSet() )
                  {
                     route.start = startObject;
                     route.waypoints = [ endObject ];
                     route.update();
                     route.storeToSession();
                     if ( scope.debug ) {
                        console.log( 'Intermediate object while dragging is "' + endObject.name + '"' );
                     }
                  }
                  else
                  {
                     route.moveWaypoint( startObject, endObject );
                     if ( startObject !== endObject ) {
                        route.update();
                     }
                     startObject = endObject;

                     console.log( 'In-route mode -- intermediate object while dragging is "' + endObject.name + '"' );
                  }

               } else {

                  endObject = undefined;

               }
            }
         }

      } else if ( state.current === 'rotate' ) {

         if ( scope.noRotate === true ) return;

         rotateEnd.set( event.clientX, event.clientY );
         rotateDelta.subVectors( rotateEnd, rotateStart );

         // rotating across whole screen goes 360 degrees around
         scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

         // rotating up and down along whole screen attempts to go 360, but limited to 180
         scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

         rotateStart.copy( rotateEnd );

      } else if ( state.current === 'dolly' ) {

         if ( scope.noZoom === true ) return;

         dollyEnd.set( event.clientX, event.clientY );
         dollyDelta.subVectors( dollyEnd, dollyStart );

         if ( dollyDelta.y > 0 ) {

            scope.dollyIn();

         } else {

            scope.dollyOut();
         }

         dollyStart.copy( dollyEnd );

      } else if ( state.current === 'pan' ) {

         if ( scope.noPan === true ) return;

         panEnd.set( event.clientX, event.clientY );
         panDelta.subVectors( panEnd, panStart );

         scope.pan( panDelta.x, panDelta.y );

         panStart.copy( panEnd );

      }

      scope.update();

   }

   function onMouseUp( event ) {

      if ( scope.enabled === false ) return;

      document.removeEventListener( 'mousemove', onMouseMove, false );
      document.removeEventListener( 'mouseup', onMouseUp, false );
      scope.dispatchEvent( endEvent );
      state.idle( event );

   }

   function onMouseWheel( event ) {

      if ( scope.enabled === false || scope.noZoom === true ) return;

      event.preventDefault();
      event.stopPropagation();

      // This doesn't need the state machine, as there's no conflict between
      // various possible actions here

      var delta = 0;

      if ( event.deltaY ) { // jquery-mousewheel

         delta = event.deltaY;

      } else if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9

         delta = event.wheelDelta;

      } else if ( event.detail ) { // Firefox

         delta = - event.detail;

      }

      if ( delta > 0 ) {

         scope.dollyOut();

      } else if ( delta < 0 ) {

         scope.dollyIn();

      }

      scope.update();
      scope.dispatchEvent( startEvent );
      scope.dispatchEvent( endEvent );
   }

   function onKeyDown( event ) {

      if ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;

      // TODO: allow modifiers at all?
      if ( event.altKey === true || event.shiftKey === true || event.ctrlKey === true || event.metaKey === true ) return;

      var $activeElement = $( document.activeElement );
      if ( $activeElement.attr( 'id' ) === 'comments' ) {
         if ( event.keyCode == scope.keys.ESCAPE || event.keyCode == scope.keys.TAB ) {
            $activeElement.blur();
         }
         return;
      }

      // This doesn't need the state machine, as there's no conflict between
      // various possible actions here

      // pan a pixel - I guess for precise positioning?
      var needUpdate = false;
      switch ( event.keyCode ) {
         case scope.keys.UP:
            event.preventDefault();
            scope.pan( 0, scope.keyPanSpeed );
            needUpdate = true;
            break;
         case scope.keys.BOTTOM:
            event.preventDefault();
            scope.pan( 0, - scope.keyPanSpeed );
            needUpdate = true;
            break;
         case scope.keys.LEFT:
            event.preventDefault();
            scope.pan( scope.keyPanSpeed, 0 );
            needUpdate = true;
            break;
         case scope.keys.RIGHT:
            event.preventDefault();
            scope.pan( - scope.keyPanSpeed, 0 );
            needUpdate = true;
            break;
         case scope.keys.ESCAPE: // Deselect selected
            window.map.deselect();
            break;
         case scope.keys.TAB: // Tab through route
            // TODO
            break;
         case scope.keys.R: // Reset orientation
            scope.rotateTo( 0, undefined, undefined );
            break;
         case scope.keys.C: // Center on default
            scope.moveTo( SCMAP.settings.cameraDefaults.target );
            break;
         case scope.keys.T: // Top view
            scope.rotateTo( 0, 0, 200 );
            break;
         case scope.keys['2']: // 2D mode
            scope.noRotate = true;
            $('#sc-map-lock-rotation').prop( 'checked', true );
            scope.map.displayState.to2d();
            scope.rotateTo( 0, 0, 180 );
            break;
         case scope.keys['3']: // 3D mode
            scope.map.displayState.to3d();
            scope.rotateTo(
               SCMAP.settings.cameraDefaults.orientation.theta,
               SCMAP.settings.cameraDefaults.orientation.phi,
               SCMAP.settings.cameraDefaults.orientation.radius
            );
            break;
         case scope.keys.L: // Lock/unlock rotation
            $('#sc-map-lock-rotation').click();
            break;
         default:
            //console.log( "onkeydown", event.keyCode );
            break;
      }

      if ( needUpdate ) {
         scope.dispatchEvent( startEvent );
         scope.dispatchEvent( endEvent );
         isMoving = true;
         scope.update();
      }
   }

   function touchstart( event ) {

      if ( scope.enabled === false ) { return; }

      //switch ( event.touches.length ) {

      //   case 1:  // one-fingered touch: rotate

      //      if ( scope.noRotate === true ) return;

      //      state = STATE.TOUCH_ROTATE;

      //      rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
      //      break;

      //   case 2:  // two-fingered touch: dolly

      //      if ( scope.noZoom === true ) return;

      //      state = STATE.TOUCH_DOLLY;

      //      var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
      //      var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
      //      var distance = Math.sqrt( dx * dx + dy * dy );
      //      dollyStart.set( 0, distance );
      //      break;

      //   case 3: // three-fingered touch: pan

      //      if ( scope.noPan === true ) return;

      //      state = STATE.TOUCH_PAN;

      //      panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
      //      break;

      //   default:

      //      state = STATE.NONE;

      //}

      scope.dispatchEvent( startEvent );

   }

   function touchmove( event ) {

      if ( scope.enabled === false ) { return; }

      event.preventDefault();
      event.stopPropagation();

      //var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

      //switch ( event.touches.length ) {

      //   case 1: // one-fingered touch: rotate

      //      if ( scope.noRotate === true ) return;
      //      if ( state !== STATE.TOUCH_ROTATE ) return;

      //      rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
      //      rotateDelta.subVectors( rotateEnd, rotateStart );

      //      // rotating across whole screen goes 360 degrees around
      //      scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
      //      // rotating up and down along whole screen attempts to go 360, but limited to 180
      //      scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

      //      rotateStart.copy( rotateEnd );

      //      scope.update();
      //      break;

      //   case 2: // two-fingered touch: dolly

      //      if ( scope.noZoom === true ) return;
      //      if ( state !== STATE.TOUCH_DOLLY ) return;

      //      var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
      //      var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
      //      var distance = Math.sqrt( dx * dx + dy * dy );

      //      dollyEnd.set( 0, distance );
      //      dollyDelta.subVectors( dollyEnd, dollyStart );

      //      if ( dollyDelta.y > 0 ) {

      //         scope.dollyOut();

      //      } else {

      //         scope.dollyIn();

      //      }

      //      dollyStart.copy( dollyEnd );

      //      scope.update();
      //      break;

      //   case 3: // three-fingered touch: pan

      //      if ( scope.noPan === true ) return;
      //      if ( state !== STATE.TOUCH_PAN ) return;

      //      panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
      //      panDelta.subVectors( panEnd, panStart );

      //      scope.pan( panDelta.x, panDelta.y );

      //      panStart.copy( panEnd );

      //      scope.update();
      //      break;

      //   default:

      //      state = STATE.NONE;

      //}

   }

   function touchend ( event ) {

      if ( scope.enabled === false ) { return; }

      scope.dispatchEvent( endEvent );
      state.idle( event );

   }

   this.idle = function idle() {
      state.idle();
   };

   state.init();

   this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
   this.domElement.addEventListener( 'mousedown', onMouseDown, false );
   this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );
   this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox

   this.domElement.addEventListener( 'touchstart', touchstart, false );
   this.domElement.addEventListener( 'touchend', touchend, false );
   this.domElement.addEventListener( 'touchmove', touchmove, false );

   window.addEventListener( 'keydown', onKeyDown, false );

   this.domElement.addEventListener( 'mousemove', onMouseMove, false );

   // force an update at start
   this.update();

};

SCMAP.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/

SCMAP.SystemLabel = function ( system ) {
   this.system = system;

   this.node = null;
   this.fontFamily = "'Segoe UI', 'Lucida Grande', 'Tahoma', 'Calibri', 'Roboto', sans-serif";

   this.textsize = 58; // px
   this.textVerticalOffset = 8.5; // number of scale 1.0 unit the text is shifted by
   this.symbolVerticalOffset = -22.5; // number of scale 1.0 units the symbols are shifted by
   this.paddingX = 6; // number of scale 1.0 units to add to the width
   this.paddingY = 36.5; // number of scale 1.0 units to add to the height

   this.symbolSize = 24;
   this.symbolSpacing = 2;
   this.outline = 2.4;

   this._width = null; // computed and cached width
   this._height = null; // computed and cached height

   // Governing label scale, can be used to shrink or enlarge the rendering
   this.scale = 1.2;
   if ( this.system.isUnknown() ) {
      this.scale = 0.8;
   }

   this.scale *= 0.74 * 2;
};
SCMAP.SystemLabel.prototype = {
   constructor: SCMAP.SystemLabel,

   clear: function clear() {
      if ( ! this.node ) {
         return;
      }
      this.node.clear();
   },

   uvCoordinates: function uvCoordinates() {
      if ( ! this.node ) {
         return null;
      }
      return this.node.uvCoordinates();
   },

   getNode: function getNode( knapsack ) {
      if ( this.node ) {
         return this.node;
      }
      var context = knapsack.canvas.getContext('2d');
      this.node = knapsack.insert({ width: Math.floor( this.width( context ) ) - 1, height: Math.floor( this.height( context ) ) - 1 });
      return this.node;
   },

   drawText: function drawText() {
      if ( ! this.node ) {
         return false;
      }
      var ctx = this.node.clipContext();
      ctx.scale( this.scale, this.scale );
      ctx.font = 'Bold '+(this.textsize)+'px '+this.fontFamily;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = this.system.factionStyle();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.lineWidth = this.outline;
      ctx.miterLimit = 2;
      ctx.fillText( this.system.name, 0, this.textVerticalOffset );
      ctx.strokeStyle = 'rgb(0,0,0)';
      ctx.strokeText( this.system.name, 0, this.textVerticalOffset );
      this.node.restoreContext();
      return true;
   },

   // Draws the icon(s) on a canvas context
   drawSymbols: function drawSymbols() {
      var symbols = this.system.getSymbols();
      var x = - ( this.symbolsWidth( symbols ) / 2 );
      var i, symbol;
      var offX, offY;

      if ( ! this.node ) {
         return false;
      }

      var ctx = this.node.clipContext();
      ctx.scale( this.scale, this.scale );

      for ( i = 0; i < symbols.length; i++ )
      {
         symbol = symbols[ i ];

         //ctx.beginPath();
         //ctx.rect( x, y - this.symbolSize - 1, this.symbolSize + 2, this.symbolSize + 2 );
         //ctx.lineWidth = 3;
         //ctx.strokeStyle = 'green';
         //ctx.stroke();

         offX = 0;
         offY = 0;
         if ( symbol.offset ) {
            offX = symbol.offset.x;
            offY = symbol.offset.y;
         }

         ctx.font = ( this.symbolSize * symbol.scale ).toFixed(2) + 'px FontAwesome';
         ctx.strokeStyle = 'rgba(0,0,0,1.0)';
         ctx.textAlign = 'center';
         ctx.lineWidth = 4;
         ctx.strokeText( symbol.code, x + offX + ( this.symbolSize / 2 ), this.symbolVerticalOffset + offY );

         ctx.fillStyle = symbol.color;
         ctx.fillText( symbol.code, x + offX + ( this.symbolSize / 2 ), this.symbolVerticalOffset + offY );

         x += this.symbolSize + this.symbolSpacing;
      }

      this.node.restoreContext();
   },

   update: function update( drawSymbols ) {
      // TODO: optimisation; redraw in same node when the size is still the same

      var curKnapsack = this.node.knapsack;

      if ( this.node ) {
         this.node.release();
         this.node = null;
      }

      this._width = null;
      this._height = null;
      this.node = window.renderer.textureManager.allocateTextureNode( this.width(), this.height() );
      if ( ! this.node ) {
         return null;
      }

      this.drawText();
      if ( drawSymbols ) {
         this.drawSymbols();
      }

      // Detect whether the texture map has been changed, then update the material
      if ( this.node.knapsack !== curKnapsack ) {
         this.sceneObject.material = new THREE.SpriteMaterial({ map: this.node.texture });
      }

      this.node.setUV();
      this.sceneObject.material.texture = this.node.texture;
      this.sceneObject.material.map.needsUpdate = true;
      this.scaleSprite();

      return true;
   },

   scaleSprite: function scaleSprite() {
      var scale = SCMAP.settings.labelScale * SCMAP.System.LABEL_SCALE;
      this.sceneObject.scale.set(
         scale * ( this.node.rectangle.width() / this.node.rectangle.height() ), scale, 1
      );
      if ( this.system.isUnknown() ) {
         this.sceneObject.scale.x *= SCMAP.System.UNKNOWN_SYSTEM_SCALE;
         this.sceneObject.scale.y *= SCMAP.System.UNKNOWN_SYSTEM_SCALE;
      }
   },

   positionSprite: function positionSprite( matrix ) {
      this.sceneObject.userData.position = new THREE.Vector3( 0, - SCMAP.settings.labelOffset, - 0.1 );
      var spriteOffset = this.sceneObject.userData.position.clone();
          spriteOffset.applyMatrix4( matrix );
      this.sceneObject.position.copy( spriteOffset );
   },

   symbolsWidth: function symbolsWidth( symbols ) {
      return ( ( this.symbolSize * symbols.length ) + ( this.symbolSpacing * ( symbols.length - 1 ) ) );
   },

   width: function width( context ) {
      var tmpWidth;
      var symbolsWidth;
      var canvas;

      if ( this._width ) {
         return this._width;
      }

      if ( !context ) {
         canvas = document.createElement( 'canvas' );
         canvas.width = 256;
         canvas.height = 100;
         context = canvas.getContext('2d');
      }

      context.font = 'Bold '+this.textsize+'px '+this.fontFamily;
      context.textBaseline = 'bottom';
      context.lineWidth = this.outline;
      tmpWidth = context.measureText( this.system.name ).width + this.paddingX;
      symbolsWidth = this.symbolsWidth( this.system.getSymbols() );
      if ( tmpWidth < symbolsWidth ) {
         tmpWidth = symbolsWidth + ( 4 * this.paddingX );
      }
      this._width = Math.floor( tmpWidth * this.scale );
      return this._width;
   },

   height: function height() {
      if ( this._height ) {
         return this._height;
      }
      this._height = Math.floor( ( this.textsize + this.paddingY ) * this.scale );
      return this._height;
   }
};

// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/
/*
 * Helper classes to generate a texture map for the text labels
 *
 * Based on: http://www.blackpawn.com/texts/lightmaps/default.html
 */

SCMAP.Knapsack = function ( canvas ) {
   this.canvas = canvas;
   this.rootNode = new SCMAP.Knapsack.Node( this );
   this.rootNode.rectangle = new SCMAP.Knapsack.Rectangle( 0, 0, canvas.width - 1, canvas.height - 1 );
};

SCMAP.Knapsack.prototype = {
   constructor: SCMAP.Knapsack,

   insert: function insert( image ) {
      var node = this.rootNode.insert( image );

      if ( node !== null ) {
         node.claim();
         //var context = this.canvas.getContext('2d');
         //context.lineWidth = 2.0;
         //context.strokeStyle = 'rgba(0,0,255,1)';
         //context.strokeRect( node.rectangle.left + 0.5, node.rectangle.top + 0.5,
         //   node.rectangle.width() - 1, node.rectangle.height() - 1 );
      }

      return node;
   }
};


SCMAP.Knapsack.Rectangle = function ( left, top, right, bottom ) {
   this.left = ( typeof left === 'number' ) ? Math.floor( left ) : 0;
   this.top = ( typeof top === 'number' ) ? Math.floor( top ) : 0;
   this.right = ( typeof right === 'number' ) ? Math.floor( right ) : 0;
   this.bottom = ( typeof bottom === 'number' ) ? Math.floor( bottom ) : 0;
};

SCMAP.Knapsack.Rectangle.prototype = {
   constructor: SCMAP.Knapsack.Node,

   Xcentre: function Xcentre() {
      return Math.floor( ( ( this.right - this.left ) / 2 ) + this.left ) - 0.5;
   },

   Ycentre: function Ycentre() {
      return Math.floor( ( ( this.bottom - this.top ) / 2 ) + this.top ) - 0.5;
   },

   width: function width() {
      return( this.right - this.left );
   },

   height: function height() {
      return( this.bottom - this.top );
   }
};


SCMAP.Knapsack.Node = function ( knapsack ) {
   this.knapsack = knapsack;
   this.canvas = knapsack.canvas;
   this.leftChild = null;
   this.rightChild = null;
   this.rectangle = null;
   this.imageID = null;
   this.texture = null;

   this.generateUUID = function generateUUID() {
      return THREE.Math.generateUUID();
   };
};

SCMAP.Knapsack.Node.prototype = {

   constructor: SCMAP.Knapsack.Node,

   claim: function claim( image ) {
      this.imageID = this.generateUUID();
   },

   release: function release() {
      if ( this.leftChild || this.rightChild ) {
         throw new Error( "Can't release tree nodes" );
      }

      this.imageID = null;
      this.clear();
      return;
   },

   clear: function clear() {
      var ctx = this.canvas.getContext('2d');
      ctx.clearRect( this.rectangle.left, this.rectangle.top, this.rectangle.width() - 1, this.rectangle.height() - 1 );
   },

   clipContext: function clipContext() {
      var ctx = this.canvas.getContext('2d');
      ctx.save();
      ctx.beginPath();
      ctx.rect( this.rectangle.left + 1, this.rectangle.top + 1, this.rectangle.width() - 2, this.rectangle.height() - 2 );
      ctx.clip();
      ctx.translate( this.rectangle.Xcentre(), this.rectangle.Ycentre() );
      return ctx;
   },
   restoreContext: function restoreContext() {
      var ctx = this.canvas.getContext('2d');
      ctx.restore();
   },

   setUV: function setUV() {
      var uvExtremes = this.uvCoordinates();
      this.texture.offset.x = uvExtremes[ 0 ];
      this.texture.offset.y = uvExtremes[ 1 ];
      this.texture.repeat.x = ( uvExtremes[ 2 ] - uvExtremes[ 0 ] );
      this.texture.repeat.y = ( uvExtremes[ 3 ] - uvExtremes[ 1 ] );
   },

   uvCoordinates: function uvCoordinates() {
      return [
         this.rectangle.left / this.canvas.width,
         1 - ( this.rectangle.bottom / this.canvas.height ),
         this.rectangle.right / this.canvas.width,
         1 - ( this.rectangle.top / this.canvas.height ),
      ];
   },

   insert: function insert( image ) {
      // if we're not a leaf then
      if ( this.leftChild || this.rightChild )
      {
         // (try inserting into first child)
         var newNode = this.leftChild.insert( image );
         if ( newNode instanceof SCMAP.Knapsack.Node ) {
            return newNode;
         }
         // (no room, insert into second)
         return this.rightChild.insert( image );
      }
      else
      {
         // (if there's already an image here, return)
         if ( this.imageID ) {
            return null;
         }

         // (if we're too small, return)
         if ( ( image.width > this.rectangle.width() ) || ( image.height > this.rectangle.height() ) ) {
            return null;
         }

         // (if we're just right, accept)
         if ( image.width === this.rectangle.width() && image.height === this.rectangle.height() ) {
            return this;
         }
        
         // (otherwise, gotta split this node and create some kids)
         this.leftChild = new SCMAP.Knapsack.Node( this );
         this.rightChild = new SCMAP.Knapsack.Node( this );

         // (decide which way to split)
         var dw = this.rectangle.width() - image.width;
         var dh = this.rectangle.height() - image.height;

         if ( dw > dh )
         {
            this.leftChild.rectangle = new SCMAP.Knapsack.Rectangle(
               this.rectangle.left, this.rectangle.top, this.rectangle.left + image.width, this.rectangle.bottom
            );

            this.rightChild.rectangle = new SCMAP.Knapsack.Rectangle(
               this.rectangle.left + image.width, this.rectangle.top, this.rectangle.right, this.rectangle.bottom
            );
         }
         else
         {
            this.leftChild.rectangle = new SCMAP.Knapsack.Rectangle(
               this.rectangle.left, this.rectangle.top, this.rectangle.right, this.rectangle.top + image.height
            );

            this.rightChild.rectangle = new SCMAP.Knapsack.Rectangle(
               this.rectangle.left, this.rectangle.top + image.height, this.rectangle.right, this.rectangle.bottom
            );
         }

         //var context = this.canvas.getContext('2d');
         //context.lineWidth = 1.0;
         //context.strokeStyle = 'rgba(255,0,0,1)';
         //context.strokeRect( this.leftChild.rectangle.left, this.leftChild.rectangle.top, this.leftChild.rectangle.width(), this.leftChild.rectangle.height() );

         //context.lineWidth = 1.0;
         //context.strokeStyle = 'rgba(0,255,0,1)';
         //context.strokeRect( this.rightChild.rectangle.left, this.rightChild.rectangle.top, this.rightChild.rectangle.width(), this.rightChild.rectangle.height() );

         // Recurse into first child we created
         return this.leftChild.insert( image );
      }
   }
};

// EOF

/**
* @author Lianna Eeftinck / https://github.com/Leeft
*/
/*
 * Manages the texture canvas(es) for the system labels using the SCMAP.Knapsack class
 */

SCMAP.TextureManager = function () {
   var canvas = document.createElement('canvas');
   canvas.width = 256 * 2;
   canvas.height = canvas.width; // * 0.4;
   //if ( window.jQuery ) {
   //   $('#debug-canvases').append( canvas );
   //}
   console.log( "SCMAP.TextureManager: Allocated "+canvas.width+"px texture map #1" );
   this.knapsacks = [ new SCMAP.Knapsack( canvas ) ];
   this.textures = [ new THREE.Texture( canvas, THREE.UVMapping ) ];
};

SCMAP.TextureManager.prototype = {
   constructor: SCMAP.TextureManager,

   allocateTextureNode: function allocateTextureNode( width, height ) {
      var knapsack, node, texture, canvas, i;

      for ( i = 0; i < this.knapsacks.length; i++ )
      {
         knapsack = this.knapsacks[ i ];
         node = knapsack.insert({ width: width, height: height });
         if ( node ) {
            node.texture = this.textures[ i ].clone();
            node.texture.needsUpdate = true;
            node.setUV();
            return node;
         }
      }

      if ( width < knapsack.canvas.width ) {

         // Didn't get a node but it *should* fit, so get a new canvas
         canvas = document.createElement('canvas');
         canvas.width = this.knapsacks[0].canvas.width;
         canvas.height = this.knapsacks[0].canvas.height;
         //if ( window.jQuery ) {
         //   $('#debug-canvases').append( canvas );
         //}
         knapsack = new SCMAP.Knapsack( canvas );
         texture = new THREE.Texture( canvas, THREE.UVMapping );
         this.knapsacks.push( knapsack );
         this.textures.push( texture );
         console.log( "SCMAP.TextureManager: Allocated "+canvas.width+"px texture map #"+(this.knapsacks.length) );
         node = knapsack.insert({ width: width, height: height });
         if ( node ) {
            node.texture = texture.clone();
            node.texture.needsUpdate = true;
            node.setUV();
            return node;
         }
      } 

      return null;
   },

   freeTextureNode: function freeTextureNode( node ) {
      if ( !node || !node.imageID ) {
         return;
      }

      node.release();
   },

   getCanvases: function getCanvases() {
      var canvases = [];
      for ( var i = 0; i < this.knapsacks.length; i += 1 ) {
         canvases.push( this.knapsacks[ i ].canvas );
      }
      return canvases;
   }
};

// EOF

var scene, map, ui, storage, renderer;

$(function() {
   if ( ! Detector.webgl ) {
      Detector.addGetWebGLMessage();
   }

   if ( hasLocalStorage() ) {
      storage = window.localStorage;
   }

   map      = new SCMAP.Map();
   renderer = new SCMAP.Renderer( map );
   ui       = new SCMAP.UI( map );
   scene    = map.scene;

   // Workaround for a Chrome (WebKit) issue where the
   // scrollable area can vanish when scrolling it
   if ( /webkit/i.test( navigator.userAgent ) ) {
      var elem = document.getElementById( 'sc-map-interface' );
      elem.addEventListener( 'scroll', function( event ) {
         var width = $('#sc-map-interface').width();
         $('#sc-map-interface').css( 'width', width + 0.1 );
      }, false );
   }

});

function smokeTest () {
   var smokeParticles = new THREE.Geometry();
   for (i = 0; i < 25; i++) {
       var particle = new THREE.Vector3( Math.random() * 8, Math.random() * 10 + 5, Math.random() * 8 );
       smokeParticles.vertices.push( particle );
   }
   var smokeTexture = THREE.ImageUtils.loadTexture('images/smoke.png');
   var smokeMaterial = new THREE.ParticleBasicMaterial({
      map: smokeTexture,
      transparent: true,
      blending: THREE.AdditiveBlending,
      size: 25,
      color: 0x111111
   });
   
   var smoke = new THREE.ParticleSystem(smokeParticles, smokeMaterial);
   smoke.sortParticles = true;
   smoke.position.x = 10;
   
   scene.add(smoke);
}

function buildCross () {
   var material = new THREE.MeshBasicMaterial( { wireframe: true, color: 0xFF0000, linewidth: 1 } );
   var group = new THREE.Object3D();
   var geo = new THREE.Geometry();
   geo.vertices.push( new THREE.Vector3( -50, 1, 0 ) );
   geo.vertices.push( new THREE.Vector3( 50, 1, 0 ) );
   var cross = new THREE.Line( geo, material );
   group.add( cross );
   geo = new THREE.Geometry();
   var material2 = new THREE.MeshBasicMaterial( { wireframe: true, color: 0xF0F000, linewidth: 1 } );
   geo.vertices.push( new THREE.Vector3( 0, 1, -50 ) );
   geo.vertices.push( new THREE.Vector3( 0, 1, 50 ) );
   cross = new THREE.Line( geo, material2 );
   group.add( cross );
   var material3 = new THREE.MeshBasicMaterial( { wireframe: true, color: 0x0000F0, linewidth: 1 } );
   geo = new THREE.Geometry();
   geo.vertices.push( new THREE.Vector3( 0, -50, 0 ) );
   geo.vertices.push( new THREE.Vector3( 0, 50, 0 ) );
   cross = new THREE.Line( geo, material3 );
   group.add( cross );
   return group;
}

function hasLocalStorage() {
   try {
      return 'localStorage' in window && window.localStorage !== null;
   } catch(e) {
      return false;
   }
}

function hasSessionStorage() {
   try {
      return 'sessionStorage' in window && window.sessionStorage !== null;
   } catch(e) {
      return false;
   }
}

Object.values = function (obj ) {
    var vals = [];
    for ( var key in obj ) {
        if ( obj.hasOwnProperty(key) ) {
            vals.push( obj[key] );
        }
    }
    return vals;
};

jQuery.fn.outerHtml = function() {
     return jQuery('<div />').append(this.eq(0).clone()).html();
};

String.prototype.toHMM = function () {
    var sec_num = parseInt(this, 10);
    var hours   = Math.floor(sec_num / 3600);
    var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
    if (minutes < 10) {minutes = "0"+minutes;}
    var time    = hours+':'+minutes;
    return time;
};

Number.prototype.toHMM = function () {
    var sec_num = parseInt(this, 10);
    var hours   = Math.floor(sec_num / 3600);
    var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
    if (minutes < 10) {minutes = "0"+minutes;}
    var time    = hours+':'+minutes;
    return time;
};

function humanSort( a, b ) {
   var x, cmp1, cmp2;
   var aa = a.name.split(/(\d+)/);
   var bb = b.name.split(/(\d+)/);

   for ( x = 0; x < Math.max( aa.length, bb.length ); x++ )
   {
      if ( aa[x] != bb[x] )
      {
         cmp1 = ( isNaN( parseInt( aa[x], 10 ) ) ) ? aa[x] : parseInt( aa[x], 10 );
         cmp2 = ( isNaN( parseInt( bb[x], 10 ) ) ) ? bb[x] : parseInt( bb[x], 10 );

         if ( cmp1 === undefined || cmp2 === undefined ) {
            return aa.length - bb.length;
         } else {
            return ( cmp1 < cmp2 ) ? -1 : 1;
         }
      }
   }

   return 0;
}

// End of file
